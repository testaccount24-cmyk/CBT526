/** rexx                                                 **/
/**********************************************************/
/** Multi parm revoke logic added for v51 *****************/
/**********************************************************/
/** Multi line instdata fixed   ***************************/
/**********************************************************/
/** profile expiration fixed    ***************************/
/**********************************************************/
/** EXEC NAME        : T50ICOMP                          **/
/** LAST MODIFIED    :  6 December  1999                 **/
/** a multiple function routine which initially breaks   **/
/** down an ID of group of IDs into 'translated data'.   **/
/** This tranlated data is a list of the ID with one line**/
/** per permission rule.                                 **/
/** This list   is then evaluated to produce the desired **/
/** output depending on the function specified.          **/
/**                                                      **/
/**                                                      **/
/**----------------INPUT REQUIRED -----------------------**/
/** PASSED ARGS        VALID VALUES                      **/
/** Function:  one of the following options:             **/
/**                                                      **/
/**   Translate:                                         **/
/**     This function is used for debugging, when        **/
/**     specified the exec writes out the translated     **/
/**     interim data for each ID specified in the        **/
/**     acidlist. This is excellent for seeing how an ID **/
/**     is being manipulated internally. Be aware this   **/
/**     function writes output directly to the screen so **/
/**     you may wish to front end this option            **/
/**     with some of of output trapping. Like the FSDISP **/
/**     exec for example.                                **/
/**                                                      **/
/**   Modify:                                            **/
/**     This function is a full screen modify facility   **/
/**     for a TSS ACID.                                  **/
/**                                                      **/
/**   Compare:                                           **/
/**     This function compare the permission of each ID  **/
/**     in the acidlist to the first ID specified in the **/
/**     list.                                            **/
/**                                                      **/
/**   Rebuild:                                           **/
/**     This function creates a stream to recreate an ID **/
/**     The stream contains the TSS create command in    **/
/**     addition to the add and permit commands that are **/
/**     generated by the permit function below.          **/
/**                                                      **/
/**   Permit:                                            **/
/**     Exactly the same output as above but with no TSS **/
/**     create command for each ID.                      **/
/**                                                      **/
/**   Listdup:                                           **/
/**     List the duplicate permissions in the acids      **/
/**     specified.                                       **/
/**                                                      **/
/**   Rpermit                                            **/
/**     This creates a stream that would recreate all    **/
/**     permissions to a resource system wide            **/
/**                                                      **/
/**   Revoke:                                            **/
/**     This creates a stream that would remove all      **/
/**     permissions from the ID.                         **/
/**                                                      **/
/**   Rrevoke:                                           **/
/**     This creates a stream that would remove all      **/
/**     permissions to a resource system wide            **/
/**                                                      **/
/**                                                      **/
/** ACIDLIST:  The list of acids to compare              **/
/**                                                      **/
/**----------------OUTPUT PRODUCED-----------------------**/
/** VALID CONDITION CODES - 00                           **/
/** ISPF VARIABLES        - SECRC                        **/
/**                                                      **/
/**----------------REQUIREMENTS--------------------------**/
/** CAN RUN STANDALONE : NO                              **/
/** ISPF ENVIRONMENT   : YES                             **/
/** EXECS CALLED WITHIN THIS EXEC :  %T50JCARD           **/
/**********************************************************/
/** Variable definitions                                 **/
/**********************************************************/
/** Input variable for vgets:                            **/
/** Makeauth = "YES" - indicates we are making an        **/
/**             authority stream                         **/
/** Makecust = If set is a custom command for this user  **/
/**            that we will include after every ACID     **/
/**            creation stream.                          **/
/**********************************************************/
/** Note : I use the '#' below to indicate a numeric     **/
/**          subscript                                   **/
/**                                                      **/
/** acidnum            How many acids were pased to me   **/
/** acids.#            The actual acids                  **/
/** accessor.#         The subscripts of the ACCESSORID= **/
/**                      lines in the list               **/
/** acidlst.name.0     How many lines of output for below**/
/** acidlst.name.#     the TSS list output for the acid  **/
/**                      in variable name                **/
/** aciddup.name.0     How many lines of output for below**/
/** aciddup.name.#     One line for each duplicate       **/
/**                      keyset that the ID has          **/
/**                      The type and resource name      **/
/**                                                      **/
/** aciddup.name.type.resource.0 = how many dups there   **/
/**                   for this key set ( there may be    **/
/**                   seven SYS1. DATASET rules)         **/
/**                                                      **/
/** aciddup.name.type.resource.# = The duplicates        **/
/**                                                      **/
/** acidrul.name.0     How many lines of output for below**/
/** acidrul.name.#     One line for each permission that **/
/**                      the acid in name has.           **/
/**                      segment                         **/
/**                      restype                         **/
/**                      resource                        **/
/**     optional ===>    DUPLICATE                       **/
/**     optional ===>    subscript                       **/
/**                                                      **/
/**     if the literal DUPLICATE appears the data for this*/
/**      line musts be retrieved from the variable:      **/
/**        aciddup.name.type.resource.subscript          **/
/**                                                      **/
/**     otherwise the data can be retireved from the     **/
/**      below variable                                  **/
/**                                                      **/
/** acidath.name.type.resource                           **/
/**                    The actual translated data from   **/
/**                      the TSS list, with all relevant **/
/**                      data in this one variable.      **/
/**                                                      **/
/** modrule.0parse.0   The number of keywords to search  **/
/**                for in a rule permission.             **/
/**                                                      **/
/** modrule.0parse.#   The keywords                      **/
/**                                                      **/
/** debug.xxxxxx       Turns on debug displays in various**/
/**                    routines for serious problems.    **/
/**                                                      **/
/**********************************************************/
ARG function ACIDLIST
debug.flow     = "YES"  /* keep this YES for basic messages. */
debug.multcon  = "NO"
debug.convert  = "NO"
debug.makeacid = "NO"
debug.balance  = "NO"
debug.modify   = "NO"
debug.getdata  = "NO"
debug.fillscr  = "YES"
debug.modrule  = "NO"
debug.resource = "NO"
debug.trans    = "NO"
fill_override = 0
signal off error
address ispexec "vget idebug profile"
if rc = 0 then do
  dflag = idebug
  address ispexec "verase idebug profile"
  debug.dflag = "YES"
  if dflag = "ALL" then debug. = "YES"
  if dflag = "NONE" then debug. = "NO"
end
address ispexec "vget makecust profile"
if rc = 0 then do
  /*************************************************/
  /** This variable should hold a custom command  **/
  /** to be included in the stream directly       **/
  /** after the create statement. The command     **/
  /** should have a $$ in it to hold the ACID     **/
  /** place in the command. DIR                   **/
  /*************************************************/
  makeacid.0custom = "YES"
  makeacid.0custom.command = makecust
  /* address ispexec "verase makecust profile" */
end
address ispexec "vget makeauth profile" /* R we making an auth stream */
make_rc = rc
say "TSA101D: makeauth check was " make_rc makeauth
if make_rc = 0 then do
  convert.0newid = "YES"
  convert.0name = " $$ "
  makeacid.0auth = "YES"
  address ispexec "verase makeauth profile"
end
trace_acid = "ANIDTOTRACE"              /* a way to trace one line */
trace_record = 21                       /* of one id.. lots of output*/
debug.trace_acid.trace_record = "TRACE"
/********************************************************/
/* Specify that these resources use the entire line     */
/********************************************************/
rname = "TSOCOMMAND"
convert.0fulline.rname = "YES"
convert.0resource.rname = "TSOC"
rname = "IMSMSC"
convert.0fulline.rname = "YES"
convert.0resource.rname = "IMSMSC"
/*******/
/* uncomment the below line for all debugs */
/* debug. = "YES"  */
maint = "Dec 06 1999"
say "TSA101D: T50ICOMP in control with parms " function acidlist
say "TSA101D: T50ICOMP Maint = " maint
SIGNAL ON ERROR NAME SEEYA
HEX00 = '00'X
DISP = "SHR"
blank59= "                                                           "
SYSENV = SYSVAR(SYSENV)
SECRC = "FAILED IN T50ICOMP. NO OTHER INFORMATION AVAILABLE"
SECRC = "FAILED DURING JOBCARD FUNCTION"
/*                          */
if substr(function,1,1) = "*" then functype = "RESOURCE"
if substr(function,1,1) = "*" then function = substr(function,2)
if debug.flow = "YES" then
  say "TSA101D: Retrieving profile variables "
address ispexec "vget ds2 profile"
address ispexec "vget newpass profile"
/**************************************************/
/* below we define which functions need a jobcard */
/**************************************************/
JOBCARD.MODIFY = "YES"
JOBCARD.PERMIT  = "YES"
JOBCARD.RPERMIT = "YES"
JOBCARD.BALANCE = "YES"
JOBCARD.RREVOKE = "YES"
JOBCARD.REVOKE  = "YES"
JOBCARD.REBUILD = "YES"
if makeauth = "YES" then jobcard.rebuild = "NO"
if sysdsn(ds2) = "OK" then do
  if jobcard.function = "YES" then do
    if debug.flow = "YES" then
      say "TSA101D: calling jobcard function. "
    address tso "%t50jcard "ds2
    disp = "MOD"
  end
  address tso "alloc ddn(outds2) dsn("ds2") "disp" reus"
end
if sysdsn(ds2) /= "OK" then do
  say "TSA101D: Output DSN unusable, data written to screen "
  screen = "YES"
end
acidlst.NAME.0 = 0
aciddup.   =  0
acidres.   =  ""
acidath.   =  hex00
PASSWORD.  =  "NO_PASSWORD_FOUND"
blanks = "        "
acidnum = 0
cmpnum  = 0
cvtnum  = 0
found.   = "NO"
create.0 = 0
BYPASS. = 0
/********************************************************/
/* these are looked for in the modify routine           */
/********************************************************/
modrule.0parse.0 = 6
MODRULE.0PARSE.1 = "LIBRARY "
MODRULE.0PARSE.2 = "ACCESS "
MODRULE.0PARSE.3 = "FACILITY "
MODRULE.0PARSE.4 = "ACTION "
MODRULE.0PARSE.5 = "UNTIL "
MODRULE.0PARSE.6 = "PRIVPGM "
MODRULE.0PANEL   = "SPIUPDT"
/********************************************************/
/* these values wont even be translated during a modify */
/********************************************************/
HOLD = "MODIFY"
BYPASS.0SUPRESS.HOLD.0 = 12
BYPASS.0SUPRESS.HOLD.1 = "ACCESSORID"
BYPASS.0SUPRESS.HOLD.2 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.3 = "NAME"
BYPASS.0SUPRESS.HOLD.4 = "TYPE"
BYPASS.0SUPRESS.HOLD.5 = "CREATED"
BYPASS.0SUPRESS.HOLD.6 = "DEPTACID"
BYPASS.0SUPRESS.HOLD.7 = "DIVACID"
BYPASS.0SUPRESS.HOLD.8 = "ZONEACID"
BYPASS.0SUPRESS.HOLD.9 = "ACID"
BYPASS.0SUPRESS.HOLD.10 = "TCONS"
BYPASS.0SUPRESS.HOLD.11 = "TRBA"
BYPASS.0SUPRESS.HOLD.12 = "TUPT"
/********************************************************/
/* these values wont even be translated during a balance*/
/********************************************************/
HOLD = "BALANCE"
BYPASS.0SUPRESS.HOLD.0 = 12
BYPASS.0SUPRESS.HOLD.1 = "ACCESSORID"
BYPASS.0SUPRESS.HOLD.2 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.3 = "NAME"
BYPASS.0SUPRESS.HOLD.4 = "TYPE"
BYPASS.0SUPRESS.HOLD.5 = "CREATED"
BYPASS.0SUPRESS.HOLD.6 = "DEPTACID"
BYPASS.0SUPRESS.HOLD.7 = "DIVACID"
BYPASS.0SUPRESS.HOLD.8 = "ZONEACID"
BYPASS.0SUPRESS.HOLD.9 = "ACID"
BYPASS.0SUPRESS.HOLD.10 = "TCONS"
BYPASS.0SUPRESS.HOLD.11 = "TRBA"
BYPASS.0SUPRESS.HOLD.12 = "TUPT"
/********************************************************/
/* end of values not to   be translated during a modify */
/********************************************************/
HOLD = "TRANSLATE"
BYPASS.0SUPRESS.HOLD.0 = 5
BYPASS.0SUPRESS.HOLD.1 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.2 = "CREATED"
BYPASS.0SUPRESS.HOLD.3 = "TCONS"
BYPASS.0SUPRESS.HOLD.4 = "TRBA"
BYPASS.0SUPRESS.HOLD.5 = "TUPT"
HOLD = "REBUILD"
BYPASS.0SUPRESS.HOLD.0 = 5
BYPASS.0SUPRESS.HOLD.1 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.2 = "CREATED"
BYPASS.0SUPRESS.HOLD.3 = "TCONS"
BYPASS.0SUPRESS.HOLD.4 = "TRBA"
BYPASS.0SUPRESS.HOLD.5 = "TUPT"
hold = "COMPARE"
BYPASS.HOLD.0 = 11
BYPASS.HOLD.1 = "ACCESSORID"
BYPASS.HOLD.2 = "NAME"
BYPASS.HOLD.3 = "TYPE"
BYPASS.HOLD.4 = "CREATED"
BYPASS.HOLD.5 = "LASTUSED"
BYPASS.HOLD.6 = "DIVACID"
BYPASS.HOLD.7 = "DEPARTMENT"
BYPASS.HOLD.8 = "DIVISION"
BYPASS.HOLD.9 = "DEPTACID"
BYPASS.HOLD.10= "ZONEACID"
BYPASS.HOLD.11= "* SEGMENT"
BYPASS.HOLD.12 = "* TCONS"
BYPASS.HOLD.13 = "* TRBA"
BYPASS.HOLD.14 = "* TUPT"
HOLD = "PERMIT"
BYPASS.HOLD.0 = 15
BYPASS.HOLD.1 = "BASE ACCESSORID"
BYPASS.HOLD.2 = "BASE NAME"
BYPASS.HOLD.3 = "BASE TYPE"
BYPASS.HOLD.4 = "AUTHORITY CREATED"
BYPASS.HOLD.5 = "AUTHORITY LASTUSED"
BYPASS.HOLD.6 = "BASE SEGMENT"
BYPASS.HOLD.7 = "* ACIDS "
BYPASS.HOLD.8 = "BASE DEPTACID"
BYPASS.HOLD.9 = "BASE DIVACID"
BYPASS.HOLD.10 = "BASE ZONEACID"
BYPASS.HOLD.11 = "* PASSWORD"
BYPASS.HOLD.12 = "AUTHORITY ACID"
BYPASS.HOLD.13 = "* TCONS"
BYPASS.HOLD.14 = "* TRBA"
BYPASS.HOLD.15 = "* TUPT"
HOLD = "REVOKE"
BYPASS.HOLD.0 = 10
BYPASS.HOLD.1 = "BASE ACCESSORID"
BYPASS.HOLD.2 = "BASE NAME"
BYPASS.HOLD.3 = "BASE TYPE"
BYPASS.HOLD.4 = "AUTHORITY CREATED"
BYPASS.HOLD.5 = "* LASTUSED"
BYPASS.HOLD.6  = "AUTHORITY ACID"
BYPASS.HOLD.7  = "BASE ZONEACID"
BYPASS.HOLD.8 = "* TCONS"
BYPASS.HOLD.9 = "* TRBA"
BYPASS.HOLD.10 = "* TUPT"
accessor.0 = 0
create_num = 0
DATA = "ALL,EXPIRE"
if debug.flow = "YES" then
  say "TSA101D: Basic initialization complete, execution begins."
 /*****************************************************************/
 /*****************************************************************/
 /* Below is the special translate area for resource functions    */
 /*****************************************************************/
 /*****************************************************************/
if functype = "RESOURCE" then do
  signal on error name badres
  acidnum = 0
  say "TSA101D: Resource processing started"
  if acidlist /= "BYPASS" then do
    ss = outtrap("HOLD.",5000)
    call vparse acidlist
    signal on error name badres
    ADDRESS TSO "TSS whohas "w.1"("w.2")"
  end
  if acidlist = "BYPASS" then do
    signal on error name baddsn
    /*****************************************************************/
    /* Lets read in the DSN and break it up into different variables */
    /*****************************************************************/
    say "TSA101D: Bypass option specified, allocating input DSN"
    address ispexec "vget ds1 profile"
    address tso "alloc ddn(inds1) dsn("ds1") shr reus"
    address mvs "EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)"
    address tso "free ddn(inds1)"
  end
  do l = 1 to hold.0
    hold.l = translate(hold.l," ",hex00) /* kill the hex 00s */
    line = hold.l
    if word(line,1) = "TSS0300I" then iterate l
    IF (GOTOWNER = "YES") & (index(line,"XAUTH ") > 0) then do
      parse var line drop keep
      line = "XA "strip(newtype) strip(keep)
    end
    if (index(line,"OWNER(") > 0) then do
      acidnum = acidnum + 1
      parse var line newtype drop 'OWNER(' owner ')' drop2
      accessor.acidnum = l
      name = owner
      acids.acidnum = name
      acidlst.name.0 = 0
      gotowner = "YES"
      if debug.resource = "YES" then
        say "Owner = " acidnum "name = " owner
    end
    if (index(line,"ACID(") > 0) then do
      parse var line drop 'ACID(' name ')' drop2
      if found.name = "NO" then do
        acidnum = acidnum + 1
        accessor.acidnum = l
        acids.acidnum = name
        found.name = "yes"
      end
      temp1 = acidlst.name.0
      if datatype(temp1) /= "NUM" then acidlst.name.0 =0
      if debug.resource = "YES" then
        say "acidnum = " acidnum "name = " name
    end
    parse var line keep 'ACID(' drop2 ')'
    line = keep
    temp = acidlst.name.0 + 1
    acidlst.name.temp = line
    acidlst.name.0 = temp
    say "TSA101D: Total acids referenced in input is " acidnum
  end
end
 /*****************************************************************/
 /*****************************************************************/
 /* End of   the special translate area for resource functions    */
 /*****************************************************************/
 /*****************************************************************/
if  functype = "RESOURCE" then   signal evaluate
if acidlist = "BYPASS" then do
  /*****************************************************************/
  /* Lets read in the DSN and break it up into different variables */
  /*****************************************************************/
  acidnum = 0
  say "TSA101D: Bypass option specified, allocating input dsn"
  address ispexec "vget ds1 profile"
  address tso "alloc ddn(inds1) dsn("ds1") shr reus"
  address mvs "EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)"
  address tso "free ddn(inds1)"
  do l = 1 to hold.0
    hold.l = translate(hold.l," ",hex00) /* kill the hex 00s */
    line = hold.l
    call vparse line
    /* say "LINE =" w.1 w.2 w.3 w.4  */
    if w.1 = "PASSWORD" THEN do
      password.name = w.3
    end
    if w.1 = "ACCESSORID" THEN do
      acidnum = acidnum + 1
      accessor.acidnum = l
      name = w.3
      acids.acidnum = w.3
      acidlst.name.0 = 0
      /* say "acidnum = " acidnum "name = " name */
    end
    /* say "acidlst."name"."temp */
    temp = acidlst.name.0 + 1
    acidlst.name.temp = hold.l
    acidlst.name.0 = temp
  end
  say "TSA101D: Total acids contained in input DSN is " acidnum
end
else do
  call vparse acidlist
  acidnum = words
  accessor.0  = 1
  accessor.1  = 1
  acids.0 = words
  do t = 1 to acidnum
    name = acids.t
    acidlst.name.0    = 0
  end
  signal on error name badacid
  do r = 1 to acidnum
    /***********************************************/
    /** here we break up the passed args into the **/
    /** ACIDS. variable so we can step thru them  **/
    /***********************************************/
    acids.r = w.r
    hold = w.r
    ss = outtrap(acidlst.hold.,5000)
    ADDRESS TSO "TSS LIST("hold") DATA("DATA")"
  end
end
/*************************************************/
/*************************************************/
/** below we creat   the translated ID stream   **/
/*************************************************/
/*************************************************/
if debug.flow = "YES" then
  say "TSA101D: Evaluation of TSS generated data begins."
evaluate: nop
do num = 1 to acidnum
  /***********************************************/
  /**This outer lop is once for each acid passed**/
  /** to me. Dave 18 June 99                    **/
  /***********************************************/
  rules = 0
  segment = "BASE"
  if functype = "RESOURCE" then segment = "AUTHORITY"
  prev_name = name
  prev_type = " "
                   /***********************************************/
  name = acids.num /* everything in the below loop uses this name */
                   /***********************************************/
  if debug.flow = "YES" then do
    say "TSA101D: Evaluation of acid # "num" begins." name
    holdaq = acidlst.name.0
    say "         Rule entries:" holdaq
  end
  if name = "RDT" then do
    SAY  "TSA102E: Unique ACID RDT not supported. Function aborted."
    secrc = "TSA102E: Unique ACID RDT not supported. Function aborted."
    address ispexec "vput secrc profile"
    exit 0
  end
  do a1 = 1 to acidlst.name.0
    concat = "NO"
    /************************************************************/
    /* the only field we do not trncate past col 59 is instdata */
    /************************************************************/
    line = acidlst.name.a1
    if word(acidlst.name.a1,1) /= "INSTDATA" then
      line = substr(acidlst.name.a1,1,59)
    /************************************************************/
    /* the only field we do not trncate past col 59 is instdata */
    /************************************************************/
    line = translate(line," ",hex00) /* kill the hex 00s */
    first11 = substr(line,1,11)
    if line = blank59 then iterate a1
    if first11 /= "           " then prevline_first11 = first11
    if first11 = "           " then do
      line = prevline_first11||substr(line,12)
    end
    if word(line,1) = "TSS0300I" then iterate a1
    if substr(line,1,2) = "  " then do
      concat = "YES"
    end
    first11 = substr(line,1,11)
    if words(first11) = 2 then
      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)
    line = first11||substr(line,12)
    line = strip(line)
    line = translate(line," ","=") /* replace = with spaces */
    if word(line,1) = "XA" then line = "XA"||substr(line,4)
    if index(line,"UNTIL(") <> 0 then do
      parse var line z1 'UNTIL(' z2 ')' z3
      line = z1 "UNTIL" z2 z3
    end
    if index(line,"TIMES(") <> 0 then do
      parse var line z1 'TIMES(' z2 ')' z3
      line = z1 "TIMES" z2 z3
    end
    call vparse line               /* fill the w. variables */
    /* say w.1 w.2 w.3 w.4 */
    if w.1 = "-----------" then do
      segment = w.2||w.3
      if w.2 = "SEGMENT" then segment = w.3
      if debug.trans = "YES" then
        say "TSA101D:  Segment changed to "segment "for " name
    end
    if w.1 = "LASTUSED" then segment = "AUTHORITY"
    if w.1 = "CREATED" then segment = "AUTHORITY"
    if w.1 = "LCFFAC" then do
      if debug.trans = "YES" then
       say "TSA101D: lcf detected:" w.2
      savefac = w.2
      iterate a1
    end
    if (w.1 = "EXMPCMDS") | (w.1 = "AUTHCMDS") then do
      if debug.trans = "YES" then
        say "TSA101D: lcf area input line:",
        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8
      w.1 = w.1"."savefac
      if debug.trans = "YES" then
        say "TSA101D: lcf area reformated line:",
        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8
    end
    if w.1 = "-----------" then iterate a1
    skipit = "NO"
    if bypass.0supress.function.0 > 0 then do
      do supnum = 1 to bypass.0supress.function.0
        if w.1 = bypass.0supress.function.supnum then skipit = "YES"
        if (skipit = "YES") & (debug.trans = "YES") then
          say "Translate skiprule tripped:" function w.1
      end
    end
    if skipit = "YES" then iterate a1
    repeat = "NO"
    if concat = "NO" then do
      prev_type = type
      prev_resource = resource
      type = strip(w.1)
      resource = strip(w.2)
      if (prev_type = type) & (prev_resource = resource) &,
         (functype /= "RESOURCE") then
        repeat = "YES"
    end
    duplicat = " "
    if repeat = "YES" then do
      /***************************************/
      /** Note the duplicates for each ID   **/
      /***************************************/
      hold = acidath.name.prev_type.prev_resource
      if debug.trans = "YES" then do
        say "TSA101D: In duplicate loop",
          concat prev_type prev_resource hold
        if debug.trans = "YES" then
          say "TSA101D: Mult key "name "==>",
            prev_type prev_resource hold
      end
      hold1 = aciddup.name.0
      hold2 = hold1 + 1
      aciddup.name.0 = hold2
      aciddup.name.hold2 = prev_type prev_resource
      if aciddup.name.hold1 = aciddup.name.hold2 then
        aciddup.name.0 = hold1
      zz1 = aciddup.name.0
      if debug.trans = "YES" then do
        say "TSA101D: New total for dup array:" name  aciddup.name.0
        say "         array key is:" aciddup.name.zz1
      end
      tz0  = aciddup.name.prev_type.prev_resource.0
      tz1  = tz0 + 1
      aciddup.name.prev_type.prev_resource.0  = tz1
      aciddup.name.prev_type.prev_resource.tz1 = hold
      duplicat = "DUPLICATE "tz1
      if debug.trans = "YES" then  do
        say "TSA101D: Mult keys" prev_type prev_resource " is now " tz1
        say "         " name prev_type prev_resource hold duplicat
      end
/*                                                                   */
/*    if aciddup.name.prev_type.prev_resource.tz0 = hold then do     */
/*      say "Full duplicate rule found dropping data:"               */
/*      say "  " prev_type prev_resource hold                        */
/*      aciddup.name.prev_type.prev_resource.0  = tz0                */
/*      duplicat = " "                                               */
/*      rules = rules -1                                             */
/*    end                                                            */
      acidath.name.type.resource = ""
      /* kill the previous one and prepare to load this one */
    end
    if concat = "YES" then do
      hold = acidath.name.type.resource
      acidath.name.type.resource = strip(hold) strip(line)
      /***************************************************/
      /* add line to current value string and set concat */
      /***************************************************/
      /*  say "T50ICOMP: Concat rule built",    */
      /*  "n="name "t="type "r="resource hold   */
      /*say "       "acidath.name.type.resource  */
      acidath.name.type.resource.0concat  = "YES"
      hold1 = acidath.name.type.resource.0concat
      hold = acidath.name.type.resource
      if debug.trans = "YES" then do
        say "TSA101D: Concat rule ",
        "n="name "t="type "r="resource hold
      end
    end
    if concat = "YES" then iterate a1
    rules = rules + 1
    acidrul.name.rules = segment type resource duplicat
    if resource = "SEGMENT" then iterate a1
    /*********************************************/
    /* set to blanks in case we have no 3rd word */
    /*********************************************/
    acidath.name.type.resource = " "
    do t1 = 3 to words
      hold = acidath.name.type.resource
      acidath.name.type.resource = strip(hold) strip(w.t1)
    end
    if debug.trans = "YES" then
      say "  Type/res=" type resource acidath.name.type.resource
  end
  acidrul.name.0 = rules
end
if debug.flow = "YES" then
  say "TSA101D: Translation streams have been built.",
  "Starting function check."
/**********************************************************/
/**The message below should only be seen if no function   */
/**routine sets the secrc variable. Normally this would   */
/**indicate that this routine was called with an invalid  */
/**function parameter                                     */
/**********************************************************/
secrc = "TSA107I: Translation complete, no other routine invoked."
/**********************************************************/
/**Below are the various functions that will use the data */
/**********************************************************/
if function = "LISTDUP" then  do
  dupnum = 0
  do x = 1 to acidnum
    name = acids.x
    /* say acidnum name  */
    say "TSA103I: "name "duplicate keysets" aciddup.name.0
    do t = 1 to aciddup.name.0
      type     = strip(word(aciddup.name.t,1))
      resource = strip(word(aciddup.name.t,2))
      tz2 = aciddup.name.type.resource.0
      prime = acidath.name.type.resource
      prime = deblank(prime)
      say " "
      say "TSA103I:"
      say " LISTDUP:"name "keyset=" type resource
      say " LISTDUP: primary:" prime
      dupnum = dupnum + 1
      listdup.dupnum = " "
      dupnum = dupnum + 1
      listdup.dupnum = " LISTDUP:"name "keyset=" type resource
      dupnum = dupnum + 1
      listdup.dupnum = "          primary:" prime
      if prime = " " then listdup.dupnum = " "
      do cnt = 1 to tz2
        hold = strip(aciddup.name.type.resource.cnt)
        hold = deblank(hold)
        dupnum = dupnum + 1
        listdup.dupnum = "    ACID=" name type resource hold
        say listdup.dupnum
        secrc = "List duplicates complete."
      end
      if screen /= "YES" then do
        address tso "alloc ddn(outds2) dsn("ds2") shr reus"
        "EXECIO "dupnum" DISKW outds2 (FINIS STEM listdup.)"
        address tso "free ddn(outds2)"
        secrc = "TSA109I: Complete. Output stream written to " ds2
      end
    end
    /* call snapshot */
    address ispexec "vput secrc profile"
  end
  exit 0
end
if (function = "PERMIT") | (function = "REVOKE"),
   | (FUNCTION = "REBUILD") then do
  if debug.flow = "YES" then
    say "TSA101D: Permit/rebuild/revoke area in control."
  call makeacid function
  if function = "REBUILD" then function = "PERMIT"
  do x = 1 to acidnum
    name = acids.x
    say "TSA101D: Starting to process ACID:" x ">"name"<"
    say "          Rules#:" acidrul.name.0
    do t = 1 to acidrul.name.0
      if debug.flow = "YES" then
        say "TSA101D: Starting to process "name " Rule #" t
      if debug.name.t = "TRACE" then trace r
      call getdata t
      hold = next
      call convert function hold
      trace off
    end
    secrc = "Conversion completed."
    address ispexec "vput secrc profile"
  end
  if screen = "YES" then do z1 = 1 to cvtnum
    say cvtcmd.z1
  end
  if screen /= "YES" then do
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = "@@"
    "EXECIO "create.0" DISKW outds2 (FINIS STEM create.)"
    if makeauth = "YES" then do
      address tso "free ddn(outds2)"
      address tso "alloc ddn(outds2) dsn("ds2") mod reus"
    end
    "EXECIO "cvtnum" DISKW outds2 (FINIS STEM cvtcmd.)"
    address tso "free ddn(outds2)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
    if makeauth = "YES" then
    secrc = "TSA523I: Sample authority stream created output is in" ds2
    address ispexec "vput secrc profile"
  end
  exit 0
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
if function = "MODIFY" then do
  if debug.modify = "YES" then
    call snapshot
  call off error
  ZPF07 = "PREVM"
  ZPF19 = "PREVM"
  ZPF08 = "NEXTM"
  ZPF20 = "NEXTM"
  "ISPEXEC VPUT ZPF07  PROFILE"
  "ISPEXEC VPUT ZPF08  PROFILE"
  "ISPEXEC VPUT ZPF19  PROFILE"
  "ISPEXEC VPUT ZPF20  PROFILE"
  Thisrec = 1
  outnum = acidrul.name.0
  panel_code = 0
  name = acids.1 /* we  only modify one acid */
  say "TSA101D:  MODIFY starting to process ACID:" name
  do until panel_code /= 0
    call fillscr
    address ispexec "display panel(SPIPROF)"
    if OPT = "NEXTM" then thisrec = thisrec + 14
    if OPT = "PREVM" then thisrec = thisrec - 14
    panel_code = rc
    call getopt
    if panel_code = 0 then do t = 1 to 14
      if f.t  = 'S' then do
        if debug.modify = "YES" then do
          say "TSA101D: S found on line" t
        end
        f.t = " "
        interpret "f"||t "= ''"
        modrule.0panel = "SPISHOW"
        call modrule  /* a read only call with above setting */
      end
      if f.t  = 'D' then do
        if debug.modify = "YES" then do
          say "TSA101D: D found on line" t
        end
        f.t = " "
        interpret "f"||t "= ''"
        y = t + thisrec - 1
        segment  = strip(word(acidrul.name.y,1))
        type     = strip(word(acidrul.name.y,2))
        resource = strip(word(acidrul.name.y,3))
        acidath.name.type.resource.0flag = "*DELETE"
        acidrul.name.y = segment type resource
        hold = segment type resource acidath.name.type.resource
        call convert "REVOKE" hold
      end
      if f.t  = 'M' then do
        if debug.modify = "YES" then do
          say "TSA101D: M found on line" t
        end
        interpret "f"||t "= ''"
        seccode = "OK"
        if authnum < 8  then call secure
        y  = t + thisrec - 1
        if seccode = "OK" then do
          segment  = strip(word(acidrul.name.y,1))
          type     = strip(word(acidrul.name.y,2))
          resource = strip(word(acidrul.name.y,3))
          hold = segment type resource acidath.name.type.resource
          say "TSA101D:"
          say "MODIFY:segment type resource acidath.name.type.resource"
          say "      "hold
          say " calling convert for revoke stream"
          call convert "REVOKE" hold
          modrule.0panel = "SPIUPDT"
          call modrule
          /* back from modify  we use new RSNAME  now */
          /* say  "back from modify  rsname is "rsname */
          acidath.name.type.rsname.0flag  = "*MODIFY"
          acidath.name.type.rsname.0concat = "YES"
          acidrul.name.y = segment type rsname
          acidath.name.type.rsname = modrule.newrs
          call convert "PERMIT" conlist
          call fillscr
          /* call snapshot */
        end
        if seccode \= "OK" then do
          say "TSA101D: secure routine failed access "
          type.hold1 = "*secure"
        end
        f.t = " "
      end
      if f.t  = 'A' then do
        if debug.modify = "YES" then do
          say "TSA101D: A found on line" t
        end
        interpret "f"||t "= ''"
        f.t = " "
        f0 = ""
        do temp3 = outnum to t by - 1
          before = temp3 - 1
          f.temp3 = f.before
          interpret "f"||temp3 "= f"||before
        end
        outnum = outnum + 1
        acidrul.name.0 = outnum
        fill = thisrec + t - 1
        target = fill + 1
     /*                                                          */
     /* say "t50icomp:addition routine entered outnum=" outnum   */
     /* say "t50icomp:addition routine entered target=" target   */
     /* say "t50icomp:addition routine entered thisrec=" thisrec */
     /* say "t50icomp:addition routine entered fill=" fill       */
        do q = outnum to target by -1
          q1 = q - 1
          acidrul.name.q = acidrul.name.q1
        end
        modrule.0panel = "SECUPDT"
        if debug.modify = "YES" then do
          say "TSA101D: Calling modrule"
        end
        call modrule
        acidath.name.type.rsname.0concat = "YES"
        acidath.name.type.rsname.0flag = "*NEWRULE"
        acidrul.name.fill = segment type rsname
        acidath.name.type.rsname = modrule.newrs
        call convert "PERMIT" conlist
        f.t = " "
        call fillscr
      end
    end
  end
  say "T50101D: leaving modify"
  secrc = "Conversion completed."
  address ispexec "vput secrc profile"
  if screen = "YES" then do z1 = 1 to cvtnum
    say cvtcmd.z1
  end
  if screen /= "YES" then do
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = "@@"
    "EXECIO "create.0" DISKW outds2 (FINIS STEM create.)"
    "EXECIO "cvtnum" DISKW outds2 (FINIS STEM cvtcmd.)"
    address tso "free ddn(outds2)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
    address ispexec "vput secrc profile"
  end
  exit 0
end
if function = "BALANCE" then do
  call off error
  name1 = acids.1
  name2 = acids.2
  /*********************************/
  /** below we create a backward  **/
  /** pointer to the full record  **/
  /** based  on restype/name      **/
  /*********************************/
  do u = 1 to 2
    daname = acids.u
    do v = 1 to acidrul.daname.0
      name = daname
      call getdata v
      gtype = getdata.0type
      gseg  = getdata.0segment
      gres  = getdata.0resource
      acidath.daname.gtype.gres.0recnum = v
    end
  end
  balout = 0
  do b1 = 1 to acidrul.name1.0
    name = name1
    bname = name1
    call getdata b1
    balout = balout + 1
    balance.balout = bname b1
    call getdata b1
    getdata.debug = "YES"
    gtype = getdata.0type
    gseg  = getdata.0segment
    gres  = getdata.0resource
 /* if debug.balance = "YES" then
      say "TSA101D: comparing " gtype gres,
      acidath.name1.gtype.gres  acidath.name2.gtype.gres  */
    if acidath.name1.gtype.gres = acidath.name2.gtype.gres then do
  /* say "SAME" acidath.name1.gtype.gres   acidath.name2.gtype.gres*/
      res_value = acidath.name2.gtype.gres
      balance.name2.gtype.gres.res_value = "$GOTIT"
      bname = "$BOTH$"
      balance.balout = bname b1
      /* say acidath.name2.gtype.gres.0recnum */
      balance.balout = balance.balout acidath.name2.gtype.gres.0recnum
      /* lets not display this one again */
      if debug.balance = "YES" then
        say "TSA101D: Values are equal" balance.balout
    end
    if symbol(acidath.name2.gtype.gres) = "VAR" then do
      if debug.balance = "YES" then
        say "TSA101D: Same rule diff access level found." balance.balout
      balout = balout + 1
      balance.name2.gtype.gres.res_value = "$GOTIT"
      balance.balout = name2 acidath.name2.gtype.gres.0recnum
    end
  end
  do b2 = 1 to acidrul.name2.0
    name = name2
    call getdata b2
    gtype = getdata.0type
    gseg  = getdata.0segment
    gres  = getdata.0resource
    res_value = acidath.name2.gtype.gres
    if balance.name2.gtype.gres.res_value = "$GOTIT" then iterate b2
    balout = balout + 1
    balance.balout = name2 b2
    /* say "setting balance to " balance.balout */
  end
  balance.0 = balout
  ZPF07 = "PREVM"
  ZPF19 = "PREVM"
  ZPF08 = "NEXTM"
  ZPF20 = "NEXTM"
  "ISPEXEC VPUT ZPF07  PROFILE"
  "ISPEXEC VPUT ZPF08  PROFILE"
  "ISPEXEC VPUT ZPF19  PROFILE"
  "ISPEXEC VPUT ZPF20  PROFILE"
  Thisrec = 1
  outnum = balance.0
  top = 1
  bot = 2
  do until bot =  outnum
    sort.top = word(balance.top,2)
    sort.bot = word(balance.bot,2)
    if sort.top > sort.bot then do
      hold = balance.top
      balance.top = balance.bot
      balance.bot = hold
      top = 0
      bot = 1
    end
    top = top + 1
    bot = bot + 1
  end
  if debug.balance = "YES" then do x2 = 1 to balout
    say "TSA101D: balance."x2 balance.x2
  end
  panel_code = 0
  say "TSA101D:  balance starting to process ACID:" name
  do until panel_code /= 0
    call fillscr
    address ispexec "display panel(SPIBLNC)"
    if OPT = "NEXTM" then thisrec = thisrec + 14
    if OPT = "PREVM" then thisrec = thisrec - 14
    panel_code = rc
    call getopt
    if panel_code = 0 then do t = 1 to 14
      balnum = t + thisrec - 1
      fill_override = word(balance.balnum,2) /* the new fill routine */
      name = a.t                           /* The acid involved */
      if f.t  = 'S' then do
        f.t = " "
        interpret "f"||t "= ''"
        if name = "$BOTH$" then name = acids.1
        modrule.0panel = "SPISHOW"
        call modrule  /* a read only call with above setting */
      end
      if f.t  = 'D' then do
        f.t = " "
        interpret "f"||t "= ''"
        y = fill_override
        if name = "$BOTH$" then do
          say "TSA101D: In duplicate name processing."
          name = acids.1
          segment  = strip(word(acidrul.name.y,1))
          type     = strip(word(acidrul.name.y,2))
          resource = strip(word(acidrul.name.y,3))
          acidath.name.type.resource.0flag = "*DELETE"
          acidrul.name.y = segment type resource
          hold = segment type resource acidath.name.type.resource
          call convert "REVOKE" hold
          name = acids.2
          y = word(balance.balnum,3)
          segment  = strip(word(acidrul.name.y,1))
          type     = strip(word(acidrul.name.y,2))
          resource = strip(word(acidrul.name.y,3))
          acidath.name.type.resource.0flag = "*DELETE"
          acidrul.name.y = segment type resource
          hold = segment type resource acidath.name.type.resource
          call convert "REVOKE" hold
        end
      end
      if f.t  = 'C' then do
        f.t = " "
        interpret "f"||t "= ''"
        y = fill_override
        if name = "$BOTH$" then do
          say "TSA101D: In duplicate name processing."
          name = acids.1
          segment  = strip(word(acidrul.name.y,1))
          type     = strip(word(acidrul.name.y,2))
          resource = strip(word(acidrul.name.y,3))
          acidath.name.type.resource.0flag = "*DELETE"
          acidrul.name.y = segment type resource
          hold = segment type resource acidath.name.type.resource
          call convert "PERMIT" hold
          y = word(balance.balnum,3)
        end
        segment  = strip(word(acidrul.name.y,1))
        type     = strip(word(acidrul.name.y,2))
        resource = strip(word(acidrul.name.y,3))
        acidath.name.type.resource.0flag = "*COPIED"
        acidrul.name.y = segment type resource
        hold = segment type resource acidath.name.type.resource
        Select
          when name = acids.1 then  name= acids.2
          when name = acids.2 then  name= acids.1
          otherwise nop
        End
        call convert "PERMIT" hold
      end
      if f.t  = 'M' then do
        interpret "f"||t "= ''"
        seccode = "OK"
        if authnum < 8  then call secure
        y = fill_override
        if seccode = "OK" then do
          segment  = strip(word(acidrul.name.y,1))
          type     = strip(word(acidrul.name.y,2))
          resource = strip(word(acidrul.name.y,3))
          hold = segment type resource acidath.name.type.resource
          say "TSA101D:"
          say "TSA101D:segment type resource acidath.name.type.resource"
          say "      "hold
          say " calling convert for revoke stream"
          call convert "REVOKE" hold
          modrule.0panel = "SPIUPDT"
          call modrule
          /* back from balance we use new RSNAME  now */
          /* say  "back from balance rsname is "rsname */
          acidath.name.type.rsname.0flag  = "*balance"
          acidath.name.type.rsname.0concat = "YES"
          acidrul.name.y = segment type rsname
          acidath.name.type.rsname = modrule.newrs
          call convert "PERMIT" conlist
          call fillscr
          /* call snapshot */
        end
        if seccode \= "OK" then do
          say "TSA101D: secure routine failed access "
          type.hold1 = "*secure"
        end
        f.t = " "
      end
    end
  end
  say "T50101D: leaving balance"
  secrc = "Conversion completed."
  address ispexec "vput secrc profile"
  if screen = "YES" then do z1 = 1 to cvtnum
    say cvtcmd.z1
  end
  if screen /= "YES" then do
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = "@@"
    "EXECIO "create.0" DISKW outds2 (FINIS STEM create.)"
    "EXECIO "cvtnum" DISKW outds2 (FINIS STEM cvtcmd.)"
    address tso "free ddn(outds2)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
    address ispexec "vput secrc profile"
  end
  exit 0
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
if function = "TRANSLATE" then say "**OUTPUTAREA**"
if function = "TRANSLATE" then do q = 1 to acidnum
  name = acids.q
  say "**NEWACID** " name
  do t = 1 to acidrul.name.0
    bypass = "no"
    type = word(acidrul.name.t,2)
    do q1 = 1 to bypass.function.0
      if type = bypass.function.q1 then bypass = "YES"
    end
    if bypass = "YES" then iterate t
    call getdata t
    say next
  end
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
if function = "COMPARE" then do
  name = acids.1    /* compare all Ids to the first one */
  cmpnum = cmpnum + 1
  compare.cmpnum = " Comparison of ACIDs " acidlist
  cmpnum = cmpnum + 1
  compare.cmpnum = "               "
  call snapshot
  do t = 1 to acidrul.name.0
    bypass = "no"
    type = word(acidrul.name.t,2)
    do q1 = 1 to bypass.function.0
      if type = bypass.function.q1 then bypass = "YES"
    end
    if bypass = "YES" then iterate t
    resource = word(acidrul.name.t,3)
    hold = acidath.name.type.resource
    do cnt = 2 to acidnum
      otherid = acids.cnt
      /******************/
      /*take a snap     */
      snaphold = name
      name = otherid
      call snapshot
      name = snaphold
      /******************/
      hold1 = acidath.otherid.type.resource
      if hold = hold1 then iterate cnt
      say "hold =" name type resource
      say "      " hold
      if hold1 = hex00 then hold1 = "**No rule **"
      say "hold1=" otherid type resource
      say "      " hold1
      cmpnum = cmpnum + 1
      compare.cmpnum =  "***********************"
      compare.cmpnum = "** Differences found **" type resource
      cmpnum = cmpnum + 1
      compare.cmpnum =  " "name  " ACID data ====>" hold
      cmpnum = cmpnum + 1
      compare.cmpnum =  " "otherid " ACID data ====>" hold1
      cmpnum = cmpnum + 1
      compare.cmpnum =  "***********************"
      cmpnum = cmpnum + 1
      compare.cmpnum =  "  "
    end
  end
  if screen /= "YES" then do
    "EXECIO "cmpnum" DISKW outds2 (FINIS STEM compare.)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
  end
  if screen = "YES" then do h1 = 1 to cmpnum
    say compare.cmpnum
  end
  address ispexec "vput secrc profile"
  exit 0
end
address ispexec "vput secrc profile"
exit 0
/************/
makeacid: procedure expose password. name accessor. acidnum acidlst.,
  acids. create_num create. screen  newpass debug. makeacid.
parse arg function
if function /= "REBUILD" then return
if debug.makeacid = "YES" then
  say "TSA101D: Making ACID:" function
own_str   =  ""
owner     =  ""
dept      =  ""
zone      =  ""
div       =  ""
do t = 1 to acidnum
  count = 1
  name = acids.t
  if name = "ALL" then return
  if name = "STC" then return
  done = "no"
  do until done = "YES"
    line = acidlst.name.count
    call vparse line
    if w.1 = "CREATED" then done = "YES"
    if count > acidlst.name.0 then done = "YES"
    if w.1 = "TYPE" then ACID_type = w.3
    IF W.4 = "NAME" THEN acid_NAME = W.6 W.7 W.8 W.9
    IF W.1 = "TYPE" THEN acid_TYPE = W.3
    if acid_type = "MASTER" then return
    IF acid_TYPE = "CENTRAL" THEN acid_TYPE = "SCA"
    /**************************************************/
    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */
    /**************************************************/
    IF W.4 = "C/A"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||"CA"
    IF W.3 = "LIMITED" THEN acid_TYPE = "LSCA"
    IF (W.1 = "ZONE") & (W.2 = "ACID")  THEN ZONE = W.4
    IF (W.1 = "DEPT") & (W.2 = "ACID")  THEN DEPT = W.4
    IF (W.1 = "DIV") & (W.2 = "ACID")  THEN DIV = W.4
    count = count + 1
  end
  user_flag = "YES"
  IF acid_type = "TYPE"     THEN USER_FLAG = "$$"
  IF acid_type = "DIVISION" THEN USER_FLAG = "NO"
  IF acid_type = "GROUP"    THEN USER_FLAG = "NO"
  IF acid_type = "DIV"      THEN acid_type= "VCA"
  IF acid_type = "DEPT"     THEN USER_FLAG = "NO"
  IF acid_type = "PROFILE"  THEN USER_FLAG = "NO"
  IF acid_type = "ZONE"     THEN USER_FLAG = "NO"
  if zone \= " " then owner = "ZONE"
  if zone \= " " then area = zone
  if div  \= " " then owner = "DIV"
  if div  \= " " then area  =  div
  if dept \= " " then owner = "DEPT"
  if dept \= " " then area  =  dept
  if ( owner \= "" ) & ( area \= "" ) then do
    own_str =  owner"("area")"
    if debug.makeacid = "YES" then
      say "TSA101D: Owner resolved to:" own_str
  end
  create_num = create_num + 1
  if password.name /= "NO_PASSWORD_FOUND" then do
    newpass = password.name
  end
  CREATE.CREATE_NUM = " TSS CRE("NAME") NAME('"ACID_NAME"') +"
  if makeacid.0auth = "YES" then create_num = create_num -1
  IF USER_FLAG = "YES" THEN
    T2 = own_str" TYPE("acid_TYPE") PASSWORD("NEWPASS")"
  ELSE
    T2=  own_str" TYPE("acid_TYPE")"
  /*                                                      */
  /*IF OWNER = "OWNER" THEN                               */
  /*  T2 = "   TYPE("acid_TYPE") PASSWORD("NEWPASS")"     */
  /*                                                      */
  if debug.makeacid = "YES" then
    say "TSA101D: Makeacid type for "name" is :" acid_type
  IF acid_TYPE = "DIVISION" THEN T2 = " TYPE("acid_TYPE")" own_str
  IF acid_TYPE = "ZONE" THEN T2 = "   TYPE("acid_TYPE")"
  IF USER_FLAG = "$$" THEN DO
    SAY "*********************************************************"
    say "TSA104E: Makeacid routine aborting due to lack of user type"
    SAY "TSA104E:   acid = "name
    SAY "*********************************************************"
    RETURN
  END
  DIV = ""
  TYPE = ""
  DEPT = ""
  ZONE = ""
  CREATE_NUM = CREATE_NUM + 1
  CREATE.CREATE_NUM = "  "T2
  CREATE_NUM = CREATE_NUM + 1
  if makeacid.0custom = "YES" then do
    thecmd = makeacid.0custom.command
    parse var thecmd q1 '$$' q2
    create.create_num = q1||name||q2
    create_num = create_num + 1
  end
  CREATE.CREATE_NUM = "  "
  CREATE.0 = CREATE_NUM
end
/* say "leaving makeacid dept = " dept  */
if debug.makeacid = "YES" then
say "TSA101D: leaving makeacid # output = "create_num create.1 create.2
if screen = "YES" then do t1 = 1 to create_num
  say create.t1
end
return
/************/
convert: procedure expose cvtcmd. name bypass. hex00,
  acidath. cvtnum concat lcffac debug. convert.
parse arg function segment inline
oname = name
if oname = "*ALL*" then oname = "ALL"
if convert.0newid = "YES" then oname = convert.0name
if debug.flow = "YES" then
  say "TSA101D: output name for convert is " oname
if debug.flow = "YES" then
  say "TSA101D: Converting for "name":"function segment ">"||inline||"<"
cmd_set = "ADD REM"
inword1 = word(inline,1)
if words(inline) = 1 then return
parse var inline gone fulline
if segment = "ADMINISTRATIONAUTHORITIES" THEN do
  cmd_set = "ADMIN DEADMIN"
  xa = "YES"
  concat = "YES"
  if index(inline,"*ALL*") <> 0 then do
    parse var inline hold0 '*ALL*' hold1
    inline = hold0||"ALL"||hold1
  end
end
cmd = word(cmd_set,1)
if function = "REVOKE" then cmd = word(cmd_set,2)
/*************************************************/
/** the reformatter area                        **/
/*************************************************/
if (inword1 = "BYPASSING") | (inword1 = "ATTRIBUTES"),
  then do
  hold = translate(substr(inline,11)," ",",")
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname")" hold
  if debug.convert = "YES" then
    say "  Reformatter area completed convert. returning."
  return
end
if (inword1 = "LCFFAC") then do
  lcffac = word(inline,2)
  if debug.convert = "YES" then
    say "  Reformatter area completed convert. returning."
  return
end
if (inword1 = "XADATASET") then do
  if debug.convert = "YES" then
    say "TSA101D: Input dsn line "inline
  inline = "XADSN"||substr(inline,10)
  if debug.convert = "YES" then
    say "TSA101D: Reformatted dsn line "inline
end
if (substr(inword1,1,9) = "AUTHCMDS."),
   | (substr(inword1,1,9) = "EXMPCMDS.") then do
  lcmd = word(inline,2)
  lcffac = substr(inword1,10)
  hold = "("lcmd
  scmd = "XCMD"
  if (substr(inword1,1,9) = "AUTHCMDS.") then scmd = "CMD"
  Do wcnt = 3 to words(inline)
    lcmd = word(inline,wcnt)
    hold = hold","lcmd
  end
  hold = hold")"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") "SCMD"("lcffac","hold")"
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
if (inword1 = "INSTDATA") then do
  hold = translate(substr(inline,10)," ",",")
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") -"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " INSTDATA('"hold"')"
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
if (inword1 = "UID") then do
  theuid = word(inline,2)
  theuid = theuid + 0  /* strip the leading zeroes */
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") UID("theuid")"
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
/*************************************************/
/** end of the reformatter area                 **/
/*************************************************/
call vparse inline
/*************************************************/
/** the preprocessing area                      **/
/*************************************************/
If w.1 = "VOLUMES" then w.1 = "VOLUME"
IF SEGMENT = "ADMINISTRATIONAUTHORITIES"  THEN do
  If w.1 = "FACILITIES" then w.1 = "FACILITY"
  If w.1 = "LISTDATA" then w.1 = "DATA"
end
if w.1 = "MASTERFAC" then w.1 = "MAS"
IF W.1 = "PROFILE" THEN CONCAT = "YES"
  /*************************************************/
  /** above to support profile expiration        **/
  /*************************************************/
if w.1 = "LOCKTIME" then do
  words = 2                 /* drop the junk */
  if w.5 /= "*ALL*" then w.2 = (w.2","w.5)
  w.1 = "LTI"
end
holdz = w.1
if convert.0fulline.holdz = "YES"  then do
  reshold = convert.0resource.holdz
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "CMD"("name")" reshold"('"fulline"')"
  return
end
if w.1 = "SITRAN" then do
  words = 2                 /* drop the junk */
  if w.4 /= "*ALL*" then w.2 = (w.2","w.4)
  w.1 = "SIT"
end
if name = "STC" then do
  if w.1 /= "STC" then return
  if w.2 = "*DEF*" then w.2 = "DEFAULT"
  HOLD  = " TSS "CMD"(STC) PROCNAME("W.2")                           "
  hold = substr(hold,1,30)
  HOLD  = hold "ACID("W.4")"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = hold
  return
end
/*************************************************/
/** end of the preprocessing area               **/
/*************************************************/
type = w.1
resource = w.2
tchk = w.2
if type = "XADSN" then tchk = "XADATASET"
if acidath.name.tchk.resource.0concat = "YES" then concat = "YES"
xa = "NO"
if substr(type,1,2) = "XA" then do
  xa = "YES"
  cmd_set = "PER REV"
  /* concat = "YES" */
  hold = acidath.name.type.resource.0concat
  if hold = "YES" then concat = "YES"
  if debug.convert = "YES" then say "TSA101D: XA",
   "type ="type "res="resource "name="name,
   "concat = " concat
  type = substr(type,3)
  w.1 = type
end
if function = "REVOKE" then cmd = word(cmd_set,2)
if function = "PERMIT" then cmd = word(cmd_set,1)
if debug.convert = "YES" then
  say "TSA101D: Resource is "resource "concat is" concat
rulehold = 0
do q1 = 1 to bypass.function.0
  hold1 = word(bypass.function.q1,1)
  hold = word(bypass.function.q1,2)
  type_check = type
  if xa = "YES" then type_check = "XA"type
  if (hold1 = "*") | (hold1 = segment) then seg_match = "YES"
  if type_CHECK = hold then type_match = "YES"
  if (type_match = "YES") & (seg_match = "YES" ) then bypass = "YES"
  if (bypass = "YES") & (rulehold = 0 ) then rulehold = q1
  seg_match  = "NO"
  type_match = "NO"
end
/*                                                */
if bypass = "YES" then do
  if debug.convert = "YES" then do
    rule = bypass.function.rulehold
    say "TSA101D: bypass rule tripped, Rule is below:"
    say "     " Rule
  end
  return
end
output = " TSS "cmd"("oname")"
if (function = "REVOKE") & (cmd = "REM") then do
  output = output w.1"("w.2")"
end
hold = ""
multi = output
/* the multi value is the tss command with multiple parms */
stack   = output
do c1 = 1 to words by 2
  next = c1 + 1
  multi = multi w.c1"("w.next")"
end
do c1 = 2 to words
  hold = hold"|"stack w.1"("w.c1")"
end
stack = hold
if debug.multcon = "YES" then do
  say "  Multi  rule  is =" multi
  say "  Stack  rule  is =" stack
  say "  Concat value is =" concat
end
/* say "Stack: =" stack  */
/* stack value is mutliple tss commands generated by one line */
/*                                                   */
/*if (function = "PERMIT") & ( xa /= "YES") then do  */
/*  do c1 = 2 to words                               */
/*    hold = hold w.c1                               */
/*  end                                              */
/*  output = output w.1"("hold")"                    */
/*end                                                */
if (function = "REVOKE") & (cmd = "REV") then do
  if concat = "YES" then output = multi
  if concat /= "YES" then output = stack
end
if (function = "PERMIT") | (function = "REBUILD") then do
  if concat = "YES" then output = multi
  if concat /= "YES" then output = stack
end
if debug.multcon = "YES" then do
  say "  Multi  rule  is =" multi
  say "  Stack  rule  is =" stack
  say "  Concat value is =" concat
end
if (type = "FACILITY") then do
  output = multi
end
parse var output tz1  '()' tz2
output = tz1 tz2
if debug.convert = "YES" then
  say "TSA101D:***** CONVERT OUTPUT IS NOW :" output
if index(output,"|") <> 0 then do
  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,
  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,
  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20
  do w = 1 to 20
    if ot.w /= "" then do
      cvtnum = cvtnum + 1
      cvtcmd.cvtnum =  ot.w
    end
  end
end
if index(output,"|") = 0 then do
  if length(output) > 60 then do
    parse var output w1 w2 w3 w4
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = " "w1 w2 w3 "-"
    output = "    "w4
    if length(output) > 60 then do
      parse var output w1 w2 w3
      cvtnum = cvtnum + 1
      cvtcmd.cvtnum =  " "w1 w2 "-"
      output = "    "w3
    end
  end
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum =  output
end
return
/*********************/
/*********************/
/*********************/
/*********************/
seeya: nop
if sysenv = "FORE" then do
  say  "T50ICOMP: error in line "sigl
  address ispexec "vput secrc profile"
  X = SOURCELINE(SIGL)
  say x
end
exit
/************/
vparse: procedure expose words w.
parse arg invar
w. = ""
words = words(invar)
do t = 1 to words
  w.t = word(invar,t)
end
return
seeya: nop
if sysenv = "FORE" then do
  secrc = "error in line "sigl
  address ispexec "vput secrc profile"
end
exit
/************************/
/************************/
/************************/
/************************/
badacid: nop
secrc = "TSA105E: TSS list command failed for ACID" acids.r
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR."
  say "passed acidlist was unlistable, check validity of acid" acids.r
  say "and your TOP SECRET authority."
  exit  8
end
say secrc
exit
/************************/
/************************/
/************************/
/************************/
baddsn: nop
secrc = "TSA106E: Unable to retrieve data to support bypass mode"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR. in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  exit  8
end
say secrc
exit
/************************/
badres: nop
secrc =,
 "TSA108E: TSS command failed, check resource type, name and authority"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  say "CMD issued: TSS whohas "w.1"("w.2")"
  say "TSS RESPONSE was:"
  say hold.1 hold.2
  exit  8
end
say secrc
exit
/************************/
badrdt: nop
secrc =,
 "TSA110E: RDT list failed, check resource type, name and authority"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  say "CMD issued: TSS list(rdt) resclass("w.1")"
  say "TSS RESPONSE was:"
  say hold.1 hold.2
  exit  8
end
say secrc
exit
/************************/
/************************/
/************************/
/************************/
fillscr: procedure expose thisrec outnum type. rsname. access. t,
 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,
 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,
 type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,
 access1 access2 access3 access4 access5 access6 access7 access8,
 access9 access10 access11 access12 access13 access14 type14,
 rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,
 rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,
 f. acidath. name hex00 aciddup. debug. balance. function balout
OPT = " "
if debug.fillscr = "YES" then
say "FILLSCR: thisrec=" thisrec
if function = "BALANCE" then outnum = balout
IF THISREC < 1 THEN DO
   THISREC = 1
   MSG = "T50PMENU: TOP OF DATA REACHED"
END
if function = "BALANCE" then
  h1 = balance.0 - 14
else
  h1 = acidrul.name.0 - 14
if h1 < 1 then h1 = 1
/*******************************************************/
/* Thisrec is the record at the top of the screen      */
/* H1 is the highest record number which should EVER   */
/* be at the top of the screen                         */
/*******************************************************/
IF (THISREC > h1 - 14) & (thisrec <> 1)  THEN DO
  THISREC = OUTNUM - 14
  MSG = "T50PMENU: BOTTOM OF DATA REACHED"
END
IF THISREC < 1 THEN DO
   THISREC = 1
   MSG = "T50PMENU: TOP OF DATA REACHED"
END
say "FILLSCR: thisrec=" thisrec
say "TSA101D: filling screen:",
  "outnum="outnum "thisrec="thisrec "h1="h1
do cnt = 1 to 14
  fill = thisrec + cnt - 1
  script = fill
  interpret "f."cnt "=  f"||cnt
  if function = "BALANCE" then do
    script = word(balance.fill,2)
    ID   = word(balance.fill,1)
    name = ID
    if ID = "$BOTH$" then name = acids.1
    a.cnt = id
    interpret "a"||cnt " =" a.cnt
    SAY "fillscr: BALANCE line "cnt " acid=" name "data# = "script
    SAY "fillscr: a."cnt "=" a.cnt "thisrec=" thisrec "fill=" fill
  end
  /* dont need segment here for doc                   */
  segment       = strip(word(acidrul.name.script,1))
  type.fill     = strip(word(acidrul.name.script,2))
  type     = type.fill
  if substr(type.fill,1,2) = "XA" then type.fill = substr(type.fill,3)
  /*********************************************/
  /* remove the XA for filling the screen only */
  /*********************************************/
  resource.fill = strip(word(acidrul.name.script,3))
  dup_check     = strip(word(acidrul.name.script,4))
  dup_num       = strip(word(acidrul.name.script,5))
  resource = resource.fill
  if acidath.name.type.resource.0flag /= hex00 then do
    type.fill = acidath.name.type.resource.0flag
    if debug.fillscr = "YES" then do
      say "fillscr: type overlayed type, resource =" type resource
      say "fillscr: NEWTYPE  =" type.fill
    end
  end
  respass = acidath.name.type.resource
  if dup_check = "DUPLICATE" then
    respass = aciddup.name.type.resource.dup_num
  hold = segment type resource respass
  parse var hold h1 'ACCESS ' access dropoff
  access.fill = access
  interpret "type"||cnt " =  type.fill"
  interpret "rsname"||cnt "= resource.fill"
  interpret "access"||cnt  "=  access.fill"
  l = type.fill resource.fill access.fill
  if debug.fillscr = "YES" then
     say "FILLSCR output:" l
  /* call convert function hold  */
end
RETURN
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
Getopt: procedure expose f.,
 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT
OPT = " "
do t = 1 to 14
  interpret "f."t "=  f"||t
end
RETURN
/************************/
/************************/
/************************/
/************************/
secure: nop
return
/************************/
/************************/
/************************/
/************************/
snapshot: procedure expose acidath. name acidrul. aciddup. next
say "TSA101D: Dumping acidrul array for " name
do out = 1 to acidrul.name.0
  call getdata out
  say out "=" next
end
return
/************************/
/************************/
/************************/
/************************/
/************************/
snaplist: procedure expose  name acidrul. aciddup. next acidlst.
say "TSA101D: Dumping acidrul array for " name
do out = 1 to acidlst.name.0
  t = acidlst.name.out
  say t
end
return
/************************/
/************************/
/************************/
/************************/
delrule: nop
return
/************************/
/************************/
/************************/
/************************/
getdata: procedure expose acidrul. aciddup. next acidath. name,
  getdata. debug.
/****************************************************************/
/* this routine passes the next translated data line for an acid*/
/****************************************************************/
arg record_number
if debug.getdata = "YES" then
  say "TSA101D: Getdata invoked with:" name record_number
t = record_number
segment  = strip(word(acidrul.name.t,1))
type     = strip(word(acidrul.name.t,2))
resource = strip(word(acidrul.name.t,3))
dupchk   = strip(word(acidrul.name.t,4))
dupnum   = strip(word(acidrul.name.t,5))
theres = acidath.name.type.resource
if debug.getdata = "YES" then do
  say "TSA101D: Getdata base resource:" acidrul.name.t
  say "TSA101D: Getdata resource data:" theres
end
if dupchk = "DUPLICATE" then do
  theres = aciddup.name.type.resource.dupnum
  if debug.getdata = "YES" then
    say "Getdata:Record # " t "Duplicate processing:" dupnum theres
end
next = segment type resource theres
if debug.getdata = "YES" then
  say "TSA101D: Getdata returning:" next
getdata.0segment  = strip(word(acidrul.name.t,1))
getdata.0type     = strip(word(acidrul.name.t,2))
getdata.0resource = strip(word(acidrul.name.t,3))
return
/************************/
/************************/
/************************/
/************************/
deblank: NOP
arg in
deblnk.0out = ""
do deblnk = 1 to words(in)
  deblnk.0out = deblnk.0out word(in,deblnk)
end
result = deblnk.0out
return result
/************************/
/************************/
/************************/
/************************/
modrule: procedure expose thisrec outnum type. rsname. access. t,
 rsname  library type access facility action until privpgm other,
 f. acidath. name acidrul. conlist modrule. rstype debug.,
 fill_override balance.
 /*************************************************************/
 /*************************************************************/
 /** This routine displays a screen and returns the variable **/
 /** conlist which is preformatted for a call to the convert **/
 /** routine.                                                **/
 /*************************************************************/
 /** output                                                  **/
 /** modrule.newrs        the new resource value             **/
 /**        rsname        the new resource name              **/
 /**        conlist       preformatted convert input         **/
 /*************************************************************/
OPT = " "
if debug.modrule = "YES" then
  say "MODRULE: Initial: t="t "thisrec="thisrec "Fill="fill
if thisrec < 1 then do
   thisrec = 1
   msg = "t50pmenu: top of data reached"
end
h1 = acidrul.name.0 - 14
if h1 < 1 then h1 = 1
if (thisrec > h1 )  then do
  thisrec = h1
  msg = "t50pmenu: bottom of data reached"
end
fill = thisrec + t - 1
if debug.modrule = "YES" then
  say "MODRULE: Resolved: t="t "thisrec="thisrec "Fill="fill
if fill_override /= 0 then do
  fill = fill_override
  fill_override = 0
  if debug.modrule = "YES" then
  say "MODRULE: fill_overide found is :" fill_override "ACID=" name
  /*******************************************************************/
  /* this fill_override variable allows the balance routine to       */
  /* bypass normal processing and pass me the subscript.             */
  /*******************************************************************/
end
interpret "f."t "=  f"||t
/* dont need segment here for doc                   */
segment       = strip(word(acidrul.name.fill,1))
type          = strip(word(acidrul.name.fill,2))
resource      = strip(word(acidrul.name.fill,3))
rsname        = strip(word(acidrul.name.fill,3))
modrule.newrs = ""
hold = acidath.name.type.resource
do modcnt = 1 to modrule.0parse.0
  target = modrule.0parse.modcnt
  interpret target " =  ''"
  if index(hold,target) <> 0 then do
    parse var hold h1 (target) gotit dropoff
    hold = h1 dropoff
    say "modrule:parse hit #"modcnt" setting " target "to" gotit
    say "modrule:remaining line" hold
    interpret   target " =  gotit"
    /* modrule.newrs = modrule.newrs target gotit    */
    /* say "modrule: new resource is " modrule.newrs   */
  end
end
other = hold
other = Deblank(other)
l = rsname library type access facility action until privpgm other
if debug.modrule = "YES" then
  say "MODRULE:prepanel" l
address ispexec "vput (action access library until type rsname) profile"
address ispexec "vput (facility privpgm ) profile"
address ispexec "addpop poploc(data2)"
/* address ispexec "setmsg msg(tssm000) msgloc(popmsg)" */
address ispexec "display panel("modrule.0panel")"
address ispexec "rempop"
conlist = segment type rsname
if access   /= " " then conlist = conlist "ACCESS " access
if facility /= " " then conlist = conlist "FAC " facility
if action   /= " " then conlist = conlist "ACTION "action
if until    /= " " then conlist = conlist "UNTIL "until
if privpgm  /= " " then conlist = conlist "PRIVPGM "privpgm
if other    /= " " then conlist = conlist other
if debug.modrule = "YES" then
  say "MODRULE:postpanel" conlist
do p = 4 to words(conlist)
  modrule.newrs = modrule.newrs word(conlist,p)
end
if debug.modrule = "YES" then
  say "Modrule: final conlist" conlist
/* call convert function hold  */
RETURN
