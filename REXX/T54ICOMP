/** rexx                                                 **/
/**********************************************************/
/**********************************************************/
/** save prior to deleting acidrul. array                **/
/**********************************************************/
/**********************************************************/
/** Updated allacid. array processing and adding comments**/
/**********************************************************/
/**********************************************************/
/** Started conversion to one array instead of one array **/
/** for each acid instream. nov 22 2002                  **/
/**********************************************************/
/**********************************************************/
/** added convert support for d,g and t,g in volume      **/
/** rules  dir may 5 2002                                **/
/**********************************************************/
/**********************************************************/
/** changed some doc spelling DIR FEB 22 2002            **/
/**********************************************************/
/** Change to modrule routine to totally remove the      **/
/** scrolling area of that routine... I don't even know  **/
/** why that section of the routine was there....        **/
/**                  DIR Novem 05 2001                   **/
/**********************************************************/
/**********************************************************/
/** July 25 2001 - documentation updates                 **/
/**********************************************************/
/** Change to debug modify processing to fix errant ptr  **/
/** Which caused some scrolling to miss records and      **/
/** caused records selected during modify to be wrongly  **/
/** grabbed.         DIR april 12 2001                   **/
/**********************************************************/
/** Discovered that modify will not support stacked/     **/
/** owned resources, and that it would be a bear to      **/
/** fix so I am leaving it alone.                        **/
/**********************************************************/
/** Fixed modify function to properly display access for **/
/** datasets.                                            **/
/**********************************************************/
/** Added the clone function to support requirements     **/
/**********************************************************/
/** Added some comments for the poor guy who will        **/
/** maintain this after I am long gone.                  **/
/**********************************************************/
/** removed balance and listdup functions due to lack    **/
/** of interest and extended support issues              **/
/**********************************************************/
/** getdata routine and translate routine changed to     **/
/** used straight subscript reference for duplicates     **/
/** so we no longer need the aciddup. stem.              **/
/**********************************************************/
/** Multi parm revoke logic added for v51 *****************/
/**********************************************************/
/** Multi line instdata fixed   ***************************/
/**********************************************************/
/** profile expiration fixed    ***************************/
/**********************************************************/
/** EXEC NAME        : T53ICOMP                          **/
/** LAST MODIFIED    : 21Novem     2002                  **/
/** a multiple function routine which initially breaks   **/
/** down an ID of group of IDs into 'translated data'.   **/
/** This tranlated data is a list of the ID with one line**/
/** per permission rule.                                 **/
/** This list   is then evaluated to produce the desired **/
/** output depending on the function specified.          **/
/**                                                      **/
/**                                                      **/
/**----------------INPUT REQUIRED -----------------------**/
/** PASSED ARGS        VALID VALUES                      **/
/** Function:  one of the following options:             **/
/**                                                      **/
/**   Translate:                                         **/
/**     This function is used for debugging, when        **/
/**     specified the exec writes out the translated     **/
/**     interim data for each ID specified in the        **/
/**     acidlist. This is excellent for seeing how an ID **/
/**     is being manipulated internally. Be aware this   **/
/**     function writes output directly to the screen so **/
/**     you may wish to front end this option            **/
/**     with some of of output trapping. Like the FSDISP **/
/**     exec for example.                                **/
/**                                                      **/
/**   Modify:                                            **/
/**     This function is a full screen modify facility   **/
/**     for a TSS ACID.                                  **/
/**                                                      **/
/**   Rebuild:                                           **/
/**     This function creates a stream to recreate an ID **/
/**     The stream contains the TSS create command in    **/
/**     addition to the add and permit commands that are **/
/**     generated by the permit function below.          **/
/**                                                      **/
/**   Clone:                                             **/
/**     This function creates a stream to create an ID   **/
/**     based on the authorities of another specified    **/
/**     ID.                                              **/
/**                                                      **/
/**   Permit:                                            **/
/**     Exactly the same output as above but with no TSS **/
/**     create command for each ID.                      **/
/**                                                      **/
/**   Rpermit                                            **/
/**     This creates a stream that would recreate all    **/
/**     permissions to a resource system wide            **/
/**                                                      **/
/**   Revoke:                                            **/
/**     This creates a stream that would remove all      **/
/**     permissions from the ID.                         **/
/**                                                      **/
/**   Rrevoke:                                           **/
/**     This creates a stream that would remove all      **/
/**     permissions to a resource system wide            **/
/**                                                      **/
/**                                                      **/
/**----------------OUTPUT PRODUCED-----------------------**/
/** VALID CONDITION CODES - 00                           **/
/** ISPF VARIABLES        - SECRC                        **/
/**                                                      **/
/**----------------REQUIREMENTS--------------------------**/
/** CAN RUN STANDALONE : NO                              **/
/** ISPF ENVIRONMENT   : YES                             **/
/** EXECS CALLED WITHIN THIS EXEC :  %T53JCARD           **/
/**********************************************************/
/** Variable definitions                                 **/
/**********************************************************/
/** Input variable for vgets:                            **/
/**                                                      **/
/** defgroup = the defgroup OMVS group for invoking the  **/
/**            %GIVEUID exec.                            **/
/**                                                      **/
/** DS1      = work dsn #1 in the SPI system             **/
/**                                                      **/
/** DS2      = work dsn #2 in the SPI system             **/
/**                                                      **/
/** idebug   = a debug value that can be set to override **/
/**            debug values in this exec                 **/
/**                                                      **/
/** Makeauth = "YES" - indicates we are making an        **/
/**             authority stream                         **/
/** Makecust = If set is a custom command for this user  **/
/**            that we will include after every ACID     **/
/**            creation stream.                          **/
/** newpass  = The password value to be used in converts **/
/**                                                      **/
/** uidcon   = a value to specify if UIDs are converted  **/
/**            'as is' or if the %giveuid exec is to be  **/
/**             used instead.                            **/
/**            NO =  The GIVEUID exec is issued for a new**/
/**              UID, unless UID is zero.                **/
/**            YES = The exact UID will be replicated    **/
/**              A UID of zero is always be replicated   **/
/**                                                      **/
/**********************************************************/
/** Note : I use the '#' below to indicate a numeric     **/
/**          subscript                                   **/
/**                                                      **/
/** acidnum            How many acids were passed to me  **/
/** acids.#            The actual acids                  **/
/** accessor.#         The subscripts of the ACCESSORID= **/
/**                      lines in the list               **/
/**********************************************************/
/** IN the below variables the 'name' area is a variable **/
/**  which is an actual ACID                             **/
/**********************************************************/
/** acidlst.name.0     How many lines of output for below**/
/** acidlst.name.#     the TSS list output for the acid  **/
/**                      in variable name                **/
/**********************************************************/
/** acidrul.name.0     How many lines of output for below**/
/** acidrul.name.#     One line for each permission that **/
/** acidrul.name.#.0type    the type                     **/
/** acidrul.name.#.0segment the segment                  **/
/** acidrul.name.#.0resname the resource name            **/
/** acidrul.name.#.0restext the resource text            **/
/**                                                      **/
/**                                                      **/
/**********************************************************/
/**                  ARRAY FLOW                          **/
/**   _______     _______      _______                   **/
/**  |       |   |       |    |       |                  **/
/**  | lst1  |   | lst2  |    | lst3  |  acidlst. arrays **/
/**  |       |   |       |    |       |                  **/
/**  |_______|   |_______|    |_______|                  **/
/**      |           |            |                      **/
/**      |           |            |                      **/
/**      |           |            |                      **/
/**   _______     _______      _______                   **/
/**  |       |   |       |    |       |                  **/
/**  | rul1  |   | rul2  |    | rul3  |  acidrul. arrays **/
/**  |       |   |       |    |       |                  **/
/**  |_______|   |_______|    |_______|                  **/
/**      |           |            |                      **/
/**      |           |            |                      **/
/**      |___________|____________|                      **/
/**                  |                                   **/
/**               _______                                **/
/**              |       |                               **/
/**              |       |                               **/
/**              |  all  |               allacid. array  **/
/**              |       |                               **/
/**              |_______|                               **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**                                                      **/
/**********************************************************/
/** In the below variable name and type and resource     **/
/**   are all variables !!                               **/
/**********************************************************/
/**                                                      **/
/** modrule.0parse.0   The number of keywords to search  **/
/**                for in a rule permission.             **/
/**                                                      **/
/** modrule.0parse.#   The keywords                      **/
/**                                                      **/
/** convert.0newid    "YES" or "NO" depending on if the  **/
/**                      ACID is changing in the convert **/
/** convert.0name     The new ACID to replace real one   **/
/**                      in the ouput stream             **/
/**                                                      **/
/** debug.xxxxxx       Turns on debug displays in various**/
/**                    routines for serious problems.    **/
/**                                                      **/
/**********************************************************/
ARG function ACIDLIST
debug.flow     = "YES"  /* keep this YES for basic messages. */
debug.multcon  = "NO"
debug.convert  = "NO"
debug.makeacid = "NO"
debug.modify   = "NO"
DEBUG.GETDATA  = "NO"
debug.fillscr  = "NO"
debug.modrule  = "NO"
debug.resource = "NO"
debug.trans    = "NO"
fill_override = 0
signal off error
address ispexec "vget uidcon profile"
address ispexec "vget defgroup profile"
address ispexec "vget idebug profile"
if rc = 0 then do
  /*****************************************************************/
  /* idebug is a value that can be set in the T$$ execs to turn on */
  /* a specific debug. U&sually for testing something.             */
  /*****************************************************************/
  dflag = idebug
  address ispexec "verase idebug profile"
  debug.dflag = "YES"
  if dflag = "ALL" then debug. = "YES"
  if dflag = "NONE" then debug. = "NO"
end
address ispexec "vget makecust profile"
if rc = 0 then do
  /*************************************************/
  /**         The MAKECUST variable               **/
  /*************************************************/
  /** This variable should hold a custom command  **/
  /** to be included in the stream directly       **/
  /** after the create statement. The command     **/
  /** should have a $$ in it to hold the ACID     **/
  /** place in the command.                       **/
  /** This would be used if you were moving IDs to**/
  /** another environment and wanted a certain    **/
  /** command included in the convert to          **/
  /** support that environment.                   **/
  /**                           DIR 25 july 2001  **/
  /**                                             **/
  /*************************************************/
  makeacid.0custom = "YES"
  makeacid.0custom.command = makecust
  /* address ispexec "verase makecust profile" */
end
  /*************************************************/
  /** A makeauth command is basically a convert   **/
  /** with two changes:                           **/
  /** 1 - The new ID is $$                        **/
  /** 2 - The tss create command is not done      **/
  /**                                             **/
  /*************************************************/
address ispexec "vget makeauth profile" /* R we making an auth stream */
make_rc = rc
say "TSA101D: makeauth check was " make_rc makeauth
if make_rc = 0 then do
  /*************************************************/
  /** Makeacid is just a type of CLONE really     **/
  /*************************************************/
  convert.0newid = "YES"
     /* tells the convert routine to change all outbound ACID */
  convert.0name = " $$ "  /* this is the new ACID name */
  makeacid.0auth = "YES"  /* tell the makeacid routine */
  address ispexec "verase makeauth profile"
end
if function = "CLONE" then do
  /*************************************************/
  /** a clone is a convert with a new ID plugged  **/
  /** into the output, so we set some flags and   **/
  /** then change function to REBUILD.            **/
  /**                                             **/
  /*************************************************/
  convert.0newid = "YES"
  convert.0name = word(acidlist,2)
  Acidlist = word(acidlist,1)
  function = "REBUILD"
  makeacid.0custom = "YES"
  uidcon = "NO"
  makeacid.0custom.command = "    %ADDLOCAL $$"
  /*************************************************/
  /** We use the makeauth feature to plug in the  **/
  /** %addlocal command into the output           **/
  /**                                             **/
  /*************************************************/
  address ispexec "verase makeauth profile"
end
trace_acid = "ANIDTOTRACE"              /* a way to trace one line */
trace_record = 21                       /* of one id.. lots of output*/
debug.trace_acid.trace_record = "TRACE"
/********************************************************/
/* Specify that these resources use the entire line     */
/********************************************************/
rname = "TSOCOMMAND"
convert.0fulline.rname = "YES"
convert.0resource.rname = "TSOC"
rname = "IMSMSC"
convert.0fulline.rname = "YES"
convert.0resource.rname = "IMSMSC"
/*******/
/* uncomment the below line for all debugs */
/* debug. = "YES"  */
maint = "Nov 22 2002"
say "TSA101D: T53ICOMP in control with parms " function acidlist
say "TSA101D: T53ICOMP Maint = " maint
SIGNAL ON ERROR NAME SEEYA
HEX00 = '00'X
DISP = "SHR"
blank59= "                                                           "
SYSENV = SYSVAR(SYSENV)
secrc = "failed in T53ICOMP. no other information available"
secrc = "failed during jobcard function"
/*                          */
if substr(function,1,1) = "*" then functype = "RESOURCE"
if substr(function,1,1) = "*" then function = substr(function,2)
  /*****************************************************************/
  /** A resource function uses an entirely different variable     **/
  /** loader routine since the input is in a radically different  **/
  /** format.                                                     **/
  /**                                                             **/
  /**                                                             **/
  /*****************************************************************/
if debug.flow = "YES" then
  say "TSA101D: Retrieving profile variables "
address ispexec "vget ds2 profile"
address ispexec "vget newpass profile"
/**************************************************/
/* below we define which functions need a jobcard */
/**************************************************/
JOBCARD.MODIFY = "YES"
JOBCARD.PERMIT  = "YES"
JOBCARD.RPERMIT = "YES"
JOBCARD.BALANCE = "YES"
JOBCARD.RREVOKE = "YES"
JOBCARD.REVOKE  = "YES"
JOBCARD.REBUILD = "YES"
if makeauth = "YES" then jobcard.rebuild = "NO"
if sysdsn(ds2) = "OK" then do
  if jobcard.function = "YES" then do
    if debug.flow = "YES" then
      say "TSA101D: calling jobcard function. "
    address tso "%T52jcard "ds2
    disp = "MOD"
  end
  address tso "alloc ddn(outds2) dsn("ds2") "disp" reus"
end
if sysdsn(ds2) /= "OK" then do
  say "TSA101D: Output DSN unusable, data written to screen "
  screen = "YES"
end
acidlst.NAME.0 = 0
aciddup.   =  0
acidres.   =  ""
PASSWORD.  =  "NO_PASSWORD_FOUND"
blanks = "        "
acidnum = 0
cmpnum  = 0
cvtnum  = 0
found.   = "NO"
create.0 = 0
BYPASS. = 0
/********************************************************/
/* these are looked for in the modify routine           */
/********************************************************/
modrule.0parse.0 = 6
MODRULE.0PARSE.1 = "LIBRARY "
MODRULE.0PARSE.2 = "ACCESS "
MODRULE.0PARSE.3 = "FACILITY "
MODRULE.0PARSE.4 = "ACTION "
MODRULE.0PARSE.5 = "UNTIL "
MODRULE.0PARSE.6 = "PRIVPGM "
MODRULE.0PANEL   = "SPIUPDT"
/********************************************************/
/* these values wont even be translated during a modify */
/********************************************************/
HOLD = "MODIFY"
BYPASS.0SUPRESS.HOLD.0 = 13
BYPASS.0SUPRESS.HOLD.1 = "ACCESSORID"
BYPASS.0SUPRESS.HOLD.2 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.3 = "NAME"
BYPASS.0SUPRESS.HOLD.4 = "TYPE"
BYPASS.0SUPRESS.HOLD.5 = "CREATED"
BYPASS.0SUPRESS.HOLD.6 = "DEPTACID"
BYPASS.0SUPRESS.HOLD.7 = "DIVACID"
BYPASS.0SUPRESS.HOLD.8 = "ZONEACID"
BYPASS.0SUPRESS.HOLD.9 = "ACID"
BYPASS.0SUPRESS.HOLD.10 = "TCONS"
BYPASS.0SUPRESS.HOLD.11 = "TRBA"
BYPASS.0SUPRESS.HOLD.12 = "TUPT"
BYPASS.0SUPRESS.HOLD.13 = "ACIDS"
/********************************************************/
/* these values wont even be translated during a balance*/
/********************************************************/
HOLD = "BALANCE"
BYPASS.0SUPRESS.HOLD.0 = 12
BYPASS.0SUPRESS.HOLD.1 = "ACCESSORID"
BYPASS.0SUPRESS.HOLD.2 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.3 = "NAME"
BYPASS.0SUPRESS.HOLD.4 = "TYPE"
BYPASS.0SUPRESS.HOLD.5 = "CREATED"
BYPASS.0SUPRESS.HOLD.6 = "DEPTACID"
BYPASS.0SUPRESS.HOLD.7 = "DIVACID"
BYPASS.0SUPRESS.HOLD.8 = "ZONEACID"
BYPASS.0SUPRESS.HOLD.9 = "ACID"
BYPASS.0SUPRESS.HOLD.10 = "TCONS"
BYPASS.0SUPRESS.HOLD.11 = "TRBA"
BYPASS.0SUPRESS.HOLD.12 = "TUPT"
/********************************************************/
/* end of values not to   be translated during a modify */
/********************************************************/
HOLD = "TRANSLATE"
BYPASS.0SUPRESS.HOLD.0 = 5
BYPASS.0SUPRESS.HOLD.1 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.2 = "CREATED"
BYPASS.0SUPRESS.HOLD.3 = "TCONS"
BYPASS.0SUPRESS.HOLD.4 = "TRBA"
BYPASS.0SUPRESS.HOLD.5 = "TUPT"
HOLD = "REBUILD"
BYPASS.0SUPRESS.HOLD.0 = 5
BYPASS.0SUPRESS.HOLD.1 = "LASTUSED"
BYPASS.0SUPRESS.HOLD.2 = "CREATED"
BYPASS.0SUPRESS.HOLD.3 = "TCONS"
BYPASS.0SUPRESS.HOLD.4 = "TRBA"
BYPASS.0SUPRESS.HOLD.5 = "TUPT"
hold = "COMPARE"
BYPASS.HOLD.0 = 11
BYPASS.HOLD.1 = "ACCESSORID"
BYPASS.HOLD.2 = "NAME"
BYPASS.HOLD.3 = "TYPE"
BYPASS.HOLD.4 = "CREATED"
BYPASS.HOLD.5 = "LASTUSED"
BYPASS.HOLD.6 = "DIVACID"
BYPASS.HOLD.7 = "DEPARTMENT"
BYPASS.HOLD.8 = "DIVISION"
BYPASS.HOLD.9 = "DEPTACID"
BYPASS.HOLD.10= "ZONEACID"
BYPASS.HOLD.11= "* SEGMENT"
BYPASS.HOLD.12 = "* TCONS"
BYPASS.HOLD.13 = "* TRBA"
BYPASS.HOLD.14 = "* TUPT"
HOLD = "PERMIT"
BYPASS.HOLD.0 = 16
BYPASS.HOLD.1 = "BASE ACCESSORID"
BYPASS.HOLD.2 = "BASE NAME"
BYPASS.HOLD.3 = "BASE TYPE"
BYPASS.HOLD.4 = "AUTHORITY CREATED"
BYPASS.HOLD.5 = "AUTHORITY LASTUSED"
BYPASS.HOLD.6 = "BASE SEGMENT"
/* BYPASS.HOLD.7 = "* ACID "  */
/* commented above due to the need for admin auth to function */
BYPASS.HOLD.7 = "* ACIDS"
BYPASS.HOLD.8 = "BASE DEPTACID"
BYPASS.HOLD.9  = "BASE DIVACID"
BYPASS.HOLD.10 = "BASE ZONEACID"
BYPASS.HOLD.12 = "* PASSWORD"
BYPASS.HOLD.13 = "AUTHORITY ACID"
BYPASS.HOLD.14 = "* TCONS"
BYPASS.HOLD.15 = "* TRBA"
BYPASS.HOLD.16 = "* TUPT"
HOLD = "REVOKE"
BYPASS.HOLD.0 = 12
BYPASS.HOLD.1 = "BASE ACCESSORID"
BYPASS.HOLD.2 = "BASE NAME"
BYPASS.HOLD.3 = "BASE TYPE"
BYPASS.HOLD.4 = "BASE DIVACID"
BYPASS.HOLD.5 = "BASE ZONEACID"
BYPASS.HOLD.6 = "AUTHORITY CREATED"
BYPASS.HOLD.7 = "* LASTUSED"
BYPASS.HOLD.8  = "AUTHORITY ACID"
BYPASS.HOLD.9  = "BASE ZONEACID"
BYPASS.HOLD.10= "* TCONS"
BYPASS.HOLD.11= "* TRBA"
BYPASS.HOLD.12 = "* TUPT"
accessor.0 = 0
create_num = 0
DATA = "ALL,EXPIRE"
/*****************************************************************/
/*****************************************************************/
/* all variables are initialized.....the main section(s) follow  */
/*****************************************************************/
/*****************************************************************/
if debug.flow = "YES" then
  say "TSA101D: Basic initialization complete, execution begins."
 /*****************************************************************/
 /*****************************************************************/
 /* Below is the special translate area for resource functions    */
 /*****************************************************************/
 /*****************************************************************/
if functype = "RESOURCE" then do
  signal on error name badres
  acidnum = 0
  say "TSA101D: Resource processing started"
  /*****************************************************************/
  /* Lets either issue the tss list or read in the data from file  */
  /*****************************************************************/
  if acidlist /= "BYPASS" then do
    ss = outtrap("HOLD.",5000)
    call vparse acidlist
    signal on error name badres
    ADDRESS TSO "TSS whohas "w.1"("w.2")"
  end
  /*****************************************************************/
  /* I code the two ifs this way because an else when in multiple  */
  /* loops is confusing...dir                                      */
  /*****************************************************************/
  if acidlist = "BYPASS" then do
    signal on error name baddsn
    /*****************************************************************/
    /* Lets read in the DSN and break it up into different variables */
    /*****************************************************************/
    say "TSA101D: Bypass option specified, allocating input DSN"
    address ispexec "vget ds1 profile"
    address tso "alloc ddn(inds1) dsn("ds1") shr reus"
    address mvs "EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)"
    address tso "free ddn(inds1)"
  end
  do l = 1 to hold.0
    hold.l = translate(hold.l," ",hex00) /* kill the hex 00s */
    line = hold.l
    if word(line,1) = "TSS0300I" then iterate l
    IF (GOTOWNER = "YES") & (index(line,"XAUTH ") > 0) then do
      parse var line drop keep
      line = "XA "strip(newtype) strip(keep)
    end
    if (index(line,"OWNER(") > 0) then do
      acidnum = acidnum + 1
      parse var line newtype drop 'OWNER(' owner ')' drop2
                           /* below we save the starting line #  */
                           /* of each acid.. not sure why        */
      accessor.acidnum = l
      name = owner
      acids.acidnum = name
      acidlst.name.0 = 0
      gotowner = "YES"
      if debug.resource = "YES" then
        say "Owner = " acidnum "name = " owner
    end
    if (index(line,"ACID(") > 0) then do
      /* lets grab the acid */
      parse var line drop 'ACID(' name ')' drop2
    /*****************************************************************/
    /* In resources the ACID with the auth is way to the right on    */
    /*  the report so we note each of them for future reference      */
    /*  Note the .name portion of the below variable insures that    */
    /*  even if one ACID has authorites in multiple areas of the     */
    /*  output, it is counted only once. The classic variable named  */
    /*  variable....                                                 */
    /*****************************************************************/
      if found.name = "NO" then do
        acidnum = acidnum + 1
        accessor.acidnum = l
        acids.acidnum = name
        found.name = "yes"
      end
      temp1 = acidlst.name.0
      if datatype(temp1) /= "NUM" then acidlst.name.0 =0
      if debug.resource = "YES" then
        say "acidnum = " acidnum "name = " name
    end
    parse var line keep 'ACID(' drop2 ')'
    line = keep
    temp = acidlst.name.0 + 1
    acidlst.name.temp = line
    acidlst.name.0 = temp
    say "TSA101D: Total acids referenced in input is " acidnum
  end
end
 /*****************************************************************/
 /*****************************************************************/
 /* End of   the special translate area for resource functions    */
 /*****************************************************************/
 /*****************************************************************/
if  functype = "RESOURCE" then signal evaluate
if acidlist = "BYPASS" then do
  /*****************************************************************/
  /* Lets read in the DSN and break it up into different variables */
  /*****************************************************************/
  acidnum = 0
  say "TSA101D: Bypass option specified, allocating input dsn"
  address ispexec "vget ds1 profile"
  address tso "alloc ddn(inds1) dsn("ds1") shr reus"
  address mvs "EXECIO * DISKR Inds1 ( FINIS STEM HOLD.)"
  address tso "free ddn(inds1)"
  do l = 1 to hold.0
    hold.l = translate(hold.l," ",hex00) /* kill the hex 00s */
    line = hold.l
    call vparse line
    /* say "LINE =" w.1 w.2 w.3 w.4  */
    if w.1 = "PASSWORD" THEN do
      password.name = w.3
    end
    if w.1 = "ACCESSORID" THEN do
      acidnum = acidnum + 1
      accessor.acidnum = l
      name = w.3
      acids.acidnum = w.3
      acidlst.name.0 = 0
      /* say "acidnum = " acidnum "name = " name */
    end
    /* say "acidlst."name"."temp */
    temp = acidlst.name.0 + 1
    acidlst.name.temp = hold.l
    acidlst.name.0 = temp
  end
  say "TSA101D: Total acids contained in input DSN is " acidnum
end
else do
  call vparse acidlist
  acidnum = words
  accessor.0  = 1
  accessor.1  = 1
  do t = 1 to acidnum
    name = acids.t
    acidlst.name.0    = 0
    /* each acid receives its own list area.. should be one */
  end
  signal on error name badacid
  do r = 1 to acidnum
    /***********************************************/
    /** here we break up the passed args into the **/
    /** ACIDS. variable so we can step thru them  **/
    /***********************************************/
    acids.r = w.r
    hold = w.r
    ss = outtrap(acidlst.hold.,5000)
    say "TSA101D: Listing ACID "hold" with data "data "."
    ADDRESS TSO "TSS LIST("hold") DATA("DATA")"
  end
end
/*************************************************/
/*************************************************/
/** below we create  the translated ID stream   **/
/*************************************************/
/*************************************************/
if debug.flow = "YES" then
  say "TSA101D: Evaluation of TSS generated data begins."
evaluate: nop  /* a branch to point for a resource convert */
/*************************************************/
/*************************************************/
/** The below routine does the exact same thing **/
/** for both resource and standard output, since**/
/** the variable structure created above is the **/
/** same for either.                            **/
/*************************************************/
/*************************************************/
linenum = 0
linehold= 0
if debug.flow = "YES" then do
  say "TSA101D: Evaluate routine in control values as follows:"
  say "acidnum:  " acidnum
  say "accessor.0" accessor.0
  say "accessor.1" accessor.1
end
rules = 0
do num = 1 to acidnum
  /************************************************/
  /**This outer loop is once for each acid passed**/
  /** to me. Dave 18 June 99                     **/
  /************************************************/
  segment = "BASE"
  if functype = "RESOURCE" then segment = "AUTHORITY"
  prev_name = name
  prev_type = " "
                   /***********************************************/
  name = acids.num /* everything in the below loop uses this name */
                   /***********************************************/
  if debug.flow = "YES" then do
    say "TSA101D: Evaluation of acid # "num" begins." name
    holdaq = acidlst.name.0
    say "         Rule entries:" holdaq
  end
  if name = "RDT" then do
    SAY  "TSA102E: Unique ACID RDT not supported. Function aborted."
    secrc = "TSA102E: Unique ACID RDT not supported. Function aborted."
    address ispexec "vput secrc profile"
    exit 0
  end
  if debug.flow = "YES" then
    say "TSA101D: Acidlst."name".0 is" acidlst.name.0
  do a1 = 1 to acidlst.name.0
    concat = "NO"
    /* */
    /* the below statements just clear the variables... */
    acidrul.name.a1.0flag    = hex00
    acidrul.name.a1.0concat  = "NO"
    setf = setval(rules,0flag,hex00)
    setf = setval(rules,0ACID,name)
    acidrul.name.a1.0segment = " "
    acidrul.name.a1.0type = " "
    acidrul.name.a1.0restext = " "
    acidrul.name.a1.0resname = " "
    /*
    setf = setval(rules,0restext," ")
    setf = setval(rules,0type," ")
    setf = setval(rules,0segment," ")
    setf = setval(rules,0concat,"NO")
    setf = setval(rules,0resname," ") */
    /************************************************************/
    /* the only field we do not trncate past col 59 is instdata */
    /************************************************************/
    line = acidlst.name.a1
    if word(acidlst.name.a1,1) /= "INSTDATA" then
      line = substr(acidlst.name.a1,1,59)
    /************************************************************/
    /* the only field we do not trncate past col 59 is instdata */
    /************************************************************/
    line = translate(line," ",hex00) /* kill the hex 00s */
    first11 = substr(line,1,11)
    if line = blank59 then iterate a1
    if first11 /= "           " then prevline_first11 = first11
    if first11 = "           " then do
      line = prevline_first11||substr(line,12)
    end
    if debug.trans = "YES" then do
      say "  "
      say "TSA101D: Translation starting for below data:"
      say "         "line
    end
    if word(line,1) = "TSS0300I" then iterate a1
    if substr(line,1,2) = "  " then do
      concat = "YES"
      acidrul.name.a1.0concat  = "YES"
      setf = setval(rules,0concat,"YES")
    end
    first11 = substr(line,1,11)
    /* below we take 2 words and make one for first 11 */
    if words(first11) = 2 then
      first11 = substr(word(line,1)||word(line,2)||blanks,1,11)
    line = first11||substr(line,12)
    line = strip(line)
    line = translate(line," ","=") /* replace = with spaces */
    if word(line,1) = "XA" then line = "XA"||substr(line,4)
    if index(line,"UNTIL(") <> 0 then do
      parse var line z1 'UNTIL(' z2 ')' z3
      line = z1 "UNTIL" z2 z3
    end
    if index(line,"TIMES(") <> 0 then do
      parse var line z1 'TIMES(' z2 ')' z3
      line = z1 "TIMES" z2 z3
    end
    call vparse line               /* fill the w. variables */
    /* say w.1 w.2 w.3 w.4 */
    if w.1 = "-----------" then do
      segment = w.2||w.3
      if w.2 = "SEGMENT" then segment = w.3
      if debug.trans = "YES" then
        say "TSA101D:  Segment changed to "segment "for " name
    end
    if w.1 = "LASTUSED" then segment = "AUTHORITY"
    if w.1 = "CREATED" then segment = "AUTHORITY"
    if w.1 = "LCFFAC" then do
      if debug.trans = "YES" then
       say "TSA101D: lcf detected:" w.2
      savefac = w.2
      iterate a1
    end
    if (w.1 = "EXMPCMDS") | (w.1 = "AUTHCMDS") then do
      if debug.trans = "YES" then
        say "TSA101D: lcf area input line:",
        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8
      w.1 = w.1"."savefac
      if debug.trans = "YES" then
        say "TSA101D: lcf area reformated line:",
        w.1 w.2 w.3 w.4 w.5 w.6 w.7 w.8
    end
    if w.1 = "-----------" then iterate a1
    skipit = "NO"
    if bypass.0supress.function.0 > 0 then do
      do supnum = 1 to bypass.0supress.function.0
        if w.1 = bypass.0supress.function.supnum then skipit = "YES"
        if (skipit = "YES") & (debug.trans = "YES") then
          say "Translate skiprule tripped:" function w.1
      end
    end
    if skipit = "YES" then linehold = linehold - 1
    if linehold < 0 then linehold = 0
    if skipit = "YES" then iterate a1
    repeat = "NO"
    if concat = "NO" then do
      prev_type = type
      prev_resource = resource
      type = strip(w.1)
      resource = strip(w.2)
      if (prev_type = type) & (prev_resource = resource) &,
         (functype /= "RESOURCE") then
        repeat = "YES"
    end
    duplicat = " "
    if concat = "YES" then do
      tzq1 = strip(line)
      hold = acidrul.name.rules.0restext
      acidrul.name.rules.0restext = strip(hold) tzq1
      setv = setval(rules,0restext,strip(hold) tzq1)
      /***************************************************/
      /* add line to current value string and set concat */
      /***************************************************/
      /*  say "T53ICOMP: Concat rule built",    */
      /*  "n="name "t="type "r="resource hold   */
      acidrul.name.rules.0concat  = "YES"
      setf = setval(rules,0concat,"YES")
 /*   say "Setting concat to yes for record " rules  */
      hold1 = acidrul.name.rules.0concat
      hold = restext(rules)
      if debug.trans = "YES" then do
        say "TSA101D: Concat rule ",
        "n="name "t="type "r="resource "h=" hold
      end
    end
    if concat = "YES" then iterate a1
    rules = rules + 1
    acidrul.name.a1.0concat  = "NO"
    setf = setval(rules,0concat,"NO")
    acidrul.name.rules = segment type resource
    acidrul.name.rules.0segment = segment
    acidrul.name.rules.0type    = type
    acidrul.name.rules.0resname = resource
    setf = setval(rules,"RESET",segment type resource)
    setf = setval(rules,0segment,segment)
    setf = setval(rules,0type,type)
    setf = setval(rules,0resname,resource)
    if resource = "SEGMENT" then iterate a1
    /*********************************************/
    /* set to blanks in case we have no 3rd word */
    /*********************************************/
    acidrul.name.rules.0restext = " "
    setf = setval(rules,0restext," ")
    do t1 = 3 to words
      hold = getval(rules,0restext)
      acidrul.name.rules.0restext = strip(hold) strip(w.t1)
      setf = setval(rules,0restext,strip(hold) strip(w.t1))
    end
    if debug.trans = "YES" then do
      say "TSA101D: Type/Rname/Text =" getval(rules,0type) "/",
      getval(rules,0resname)"/",
      getval(rules,0restext)
    end
  end
  acidrul.name.0 = rules
  linenum = linenum + rules
end
say "Total lines of translated data is:" linenum
allacid.0 = rules
if debug.flow = "YES" then
  say "TSA101D: Translation streams have been built.",
  "Starting function check."
/**********************************************************/
/**The message below should only be seen if no function   */
/**routine sets the secrc variable. Normally this would   */
/**indicate that this routine was called with an invalid  */
/**function parameter, or we did a translate function.    */
/**********************************************************/
secrc = "TSA107I: Translation complete, no other routine invoked."
/**********************************************************/
/**Below are the various functions that will use the data */
/**********************************************************/
if (function = "PERMIT") | (function = "REVOKE"),
   | (FUNCTION = "REBUILD") then do
  if debug.flow = "YES" then
    say "TSA101D: Permit/rebuild/revoke area in control."
  call makeacid function
  if function = "REBUILD" then function = "PERMIT"
  do t = 1 to allacid.0
    if debug.flow = "YES" then
      say "TSA101D: Starting to process LINE #" t
    if debug.name.t = "TRACE" then trace r
    call getadata t
    hold = next
    record_number = t
    name = allacid.t.0acid
    call convert function hold
    trace off
    secrc = "Conversion completed."
    address ispexec "vput secrc profile"
  end
  if screen = "YES" then do z1 = 1 to cvtnum
    say cvtcmd.z1
  end
  if screen /= "YES" then do
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = "@@"
    "EXECIO "create.0" DISKW outds2 (FINIS STEM create.)"
    if makeauth = "YES" then do
      cvtnum = cvtnum - 1
      address tso "free ddn(outds2)"
      address tso "alloc ddn(outds2) dsn("ds2") mod reus"
    end
    "EXECIO "cvtnum" DISKW outds2 (FINIS STEM cvtcmd.)"
    address tso "free ddn(outds2)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
    if makeauth = "YES" then
    secrc = "TSA523I: Sample authority stream created output is in" ds2
    address ispexec "vput secrc profile"
  end
  exit 0
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
if function = "MODIFY" then do
  if debug.modify = "YES" then
    call snapshot
  call off error
  ZPF07 = "PREVM"
  ZPF19 = "PREVM"
  ZPF08 = "NEXTM"
  ZPF20 = "NEXTM"
  "ISPEXEC VPUT ZPF07  PROFILE"
  "ISPEXEC VPUT ZPF08  PROFILE"
  "ISPEXEC VPUT ZPF19  PROFILE"
  "ISPEXEC VPUT ZPF20  PROFILE"
  Thisrec = 1
  outnum = linenum
  panel_code = 0
  name = acids.1 /* we  only modify one acid */
  say "TSA101D:  MODIFY starting to process ACID:" name
  do until panel_code /= 0
    call fillscr
    address ispexec "display panel(SPIPROF)"
    /* thisrec is the rec at the top of the screen */
    if OPT = "NEXTM" then thisrec = thisrec + 14
    if OPT = "PREVM" then thisrec = thisrec - 14
    panel_code = rc
    call getopt /* scan the screen for an option */
    if panel_code = 0 then do t = 1 to 14
      if f.t  = 'S' then do
        if debug.modify = "YES" then do
          say "TSA101D: S found on line" t
        end
        f.t = " "
        interpret "f"||t "= ''"
        modrule.0panel = "SPISHOW"
        call modrule  /* a read only call with above setting */
      end
      if f.t  = 'D' then do
        if debug.modify = "YES" then do
          say "TSA101D: D found on line" t
        end
        f.t = " "
        interpret "f"||t "= ''"
        y = t + thisrec - 1
        segment  = segment(y)
        type     = type(y)
        resource = resname(y)
        restext  = restext(y)
        record_number = y
        zqd = setflag(y,"*DELETE")   /* mark this record as deleted */
        acidrul.name.y = segment type resource
        setf = setval(y,"RESET",segment type resource,)
        hold = segment type resource restext
        call convert "REVOKE" hold
      end
      if f.t  = 'M' then do
        if debug.modify = "YES" then do
          say "TSA101D: M found on line" t
        end
        interpret "f"||t "= ''"
        seccode = "OK"
        if authnum < 8  then call secure
        y  = t + thisrec - 1
        say "TSA101D: t=" t "thisrec=" thisrec
        say "TSA101D: Subscript is now:" y
        if seccode = "OK" then do
          segment  = segment(y)
          type     = type(y)
          resource = resname(y)
          restext  = restext(y)
          record_number = y
          hold = segment type resource restext
          say "TSA101D:"
          say "MODIFY:segment type resource "
          say "      "hold
          say " calling convert for revoke stream"
          call convert "REVOKE" hold
          modrule.0panel = "SPIUPDT"
          call modrule
          /* back from modify  we use new RSNAME  now */
          /* modrule creates the variable conlist     */
          say  "back from modify  rsname is "rsname
          say  "back from modify  modrule.newrs is " modrule.newrs
          setf = setflag(y,'*MODIFY')
          /* */
          setf = setval(y,0concat,"YES")
          acidrul.name.y.0concat = "YES"
          /* */
          acidrul.name.y = segment type rsname
          setf = setval(y,"RESET",segment type rsname,)
          /* */
          acidrul.name.y.0resname  = rsname
          setf = setval(y,0resname,rsname)
          /* */
          acidrul.name.y.0restext  = modrule.newrs
          setf = setval(y,0restext,modrule.newrs)
          /* */
          call convert "PERMIT" conlist
          call fillscr
          /* call snapshot */
        end
        if seccode \= "OK" then do
          say "TSA101D: secure routine failed access "
          type.hold1 = "*secure"
        end
        f.t = " "
      end
      if f.t  = 'A' then do
        if debug.modify = "YES" then do
          say "TSA101D: A found on line" t
        end
        interpret "f"||t "= ''"
        f.t = " "
        f0 = ""
        do temp3 = outnum to t by - 1
          before = temp3 - 1
          f.temp3 = f.before
          interpret "f"||temp3 "= f"||before
        end
        outnum = outnum + 1
        acidrul.name.0 = outnum
        fill = thisrec + t - 1
        target = fill + 1
/*      say "T53ICOMP:addition routine entered outnum=" outnum
        say "T53ICOMP:addition routine entered target=" target
        say "T53ICOMP:addition routine entered thisrec=" thisrec
        say "T53ICOMP:addition routine entered fill=" fill
        say "Looping from "outnum "to "target                    */
        do q = outnum to target by -1
          q1 = q - 1
          /* Say "moving record "q1 "to record " q   */
          acidrul.name.q = acidrul.name.q1
          /*** zzzzebra **/
          acidrul.name.q.0segment = acidrul.name.q1.0segment
          f = setval(q,0segment,getval(q1,0segment))
          acidrul.name.q.0flag    = acidrul.name.q1.0flag
          f = setval(q,0flag,getval(q1,0flag))
          acidrul.name.q.0type    = acidrul.name.q1.0type
          f = setval(q,0type,getval(q1,0type))
          acidrul.name.q.0restext = acidrul.name.q1.0restext
          f = setval(q,0restext,getval(q1,0restext))
          acidrul.name.q.0resname = acidrul.name.q1.0resname
          f = setval(q,0resname,getval(q1,0resname))
        end
     /* say "y is now " y "fill is now " fill     */
        modrule.0panel = "SECUPDT"
        if debug.modify = "YES" then do
          say "TSA101D: Calling modrule"
        end
        call modrule
        acidrul.name.fill.0concat = "YES"
        setit = setval(fill,0concat,"YES")
        setit = setflag(fill,"*NEWRULE")
        setit = setval(fill,0flag,"*NEWRULE")
        acidrul.name.fill.0type     = type
        setit = setval(fill,0type,type)
        acidrul.name.fill.0segment  = segment
        setit = setval(fill,0segment,segment)
        acidrul.name.fill.0resname  = rsname
        setit = setval(fill,0rsname,rsname)
        acidrul.name.fill.0restext  = modrule.newrs
        acidrul.name.fill.0restext  = modrule.newrs
        record_number = fill
        call convert "PERMIT" conlist
        f.t = " "
        call fillscr
      end
    end
  end
  say "TSA101D: leaving modify"
  secrc = "Conversion completed."
  address ispexec "vput secrc profile"
  if screen = "YES" then do z1 = 1 to cvtnum
    say cvtcmd.z1
  end
  if screen /= "YES" then do
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = "@@"
    if MAKEAUTH = "YES" then
      cvtnum = cvtnum - 1
    "EXECIO "create.0" DISKW outds2 (FINIS STEM create.)"
    "EXECIO "cvtnum" DISKW outds2 (FINIS STEM cvtcmd.)"
    address tso "free ddn(outds2)"
    secrc = "TSA109I: Complete. Output stream written to " ds2
    address ispexec "vput secrc profile"
  end
  exit 0
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
if function = "TRANSLATE" then say "**OUTPUTAREA**"
if function = "TRANSLATE" then
  say "acidrul.name array || multiline ? || segment || data "
if function = "TRANSLATE" then do q = 1 to acidnum
  name = acids.q
  say "**NEWACID** " name
  do t = 1 to acidrul.name.0
    bypass = "no"
    type = word(acidrul.name.t,2)
    do q1 = 1 to bypass.function.0
      if type = bypass.function.q1 then bypass = "YES"
    end
    if bypass = "YES" then iterate t
    l1 = acidrul.name.t.0concat
    call getdata t
    say t l1 next
  end
end
if function = "TRANSLATE" then do qt = 1 to allacid.0
    say qt allacid.qt.0concat allacid.qt allacid.qt.0restext
end
/************************************************/
/************************************************/
/************************************************/
/************************************************/
address ispexec "vput secrc profile"
exit 0
/************/
makeacid: procedure expose password. name accessor. acidnum acidlst.,
  acids. create_num create. screen  newpass debug. makeacid. convert.
parse arg function
if function /= "REBUILD" then return
if debug.makeacid = "YES" then
  say "TSA101D: Making ACID:" function
own_str   =  ""
owner     =  ""
dept      =  ""
zone      =  ""
div       =  ""
do t = 1 to acidnum
  count = 1
  name = acids.t
  if name = "ALL" then return
  if name = "STC" then return
  done = "no"
  do until done = "YES"
    line = acidlst.name.count
    call vparse line
    if w.1 = "CREATED" then done = "YES"
    if count > acidlst.name.0 then done = "YES"
    if w.1 = "TYPE" then ACID_type = w.3
    IF W.4 = "NAME" THEN acid_NAME = W.6 W.7 W.8 W.9
    IF W.1 = "TYPE" THEN acid_TYPE = W.3
    if acid_type = "MASTER" then return
    IF acid_TYPE = "CENTRAL" THEN acid_TYPE = "SCA"
    /**************************************************/
    /* LETS FIGURE OUT IF THIS ID IS AN ADMINISTRATOR */
    /**************************************************/
    IF W.4 = "C/A"  THEN acid_TYPE = SUBSTR(acid_TYPE,1,1)||"CA"
    IF W.3 = "DIV"  THEN acid_TYPE = "VCA"
    IF W.3 = "LIMITED" THEN acid_TYPE = "LSCA"
    IF (W.1 = "ZONE") & (W.2 = "ACID")  THEN ZONE = W.4
    IF (W.1 = "DEPT") & (W.2 = "ACID")  THEN DEPT = W.4
    IF (W.1 = "DIV") & (W.2 = "ACID")  THEN DIV = W.4
    count = count + 1
  end
  user_flag = "YES"
  IF acid_type = "TYPE"     THEN USER_FLAG = "$$"
  IF acid_type = "DIVISION" THEN USER_FLAG = "NO"
  IF acid_type = "GROUP"    THEN USER_FLAG = "NO"
  IF acid_type = "DIV"      THEN acid_type= "VCA"
  IF acid_type = "DEPT"     THEN USER_FLAG = "NO"
  IF acid_type = "PROFILE"  THEN USER_FLAG = "NO"
  IF acid_type = "ZONE"     THEN USER_FLAG = "NO"
  if zone \= " " then owner = "ZONE"
  if zone \= " " then area = zone
  if div  \= " " then owner = "DIV"
  if div  \= " " then area  =  div
  if dept \= " " then owner = "DEPT"
  if dept \= " " then area  =  dept
  if ( owner \= "" ) & ( area \= "" ) then do
    own_str =  owner"("area")"
    if debug.makeacid = "YES" then
      say "TSA101D: Owner resolved to:" own_str
  end
  create_num = create_num + 1
  if password.name /= "NO_PASSWORD_FOUND" then do
    newpass = password.name
  end
  aname = name
  if convert.0newid = "YES" then aname = convert.0name
  CREATE.CREATE_NUM = " TSS CRE("ANAME") NAME('"ACID_NAME"') +"
  if makeacid.0auth = "YES" then create_num = create_num -1
  IF USER_FLAG = "YES" THEN
    T2 = own_str" TYPE("acid_TYPE") PASSWORD("NEWPASS")"
  ELSE
    T2=  own_str" TYPE("acid_TYPE")"
  /*                                                      */
  /*IF OWNER = "OWNER" THEN                               */
  /*  T2 = "   TYPE("acid_TYPE") PASSWORD("NEWPASS")"     */
  /*                                                      */
  if debug.makeacid = "YES" then
    say "TSA101D: Makeacid type for "name" is :" acid_type
  IF acid_TYPE = "DIVISION" THEN T2 = " TYPE("acid_TYPE")" own_str
  IF acid_TYPE = "ZONE" THEN T2 = "   TYPE("acid_TYPE")"
  IF USER_FLAG = "$$" THEN DO
    SAY "*********************************************************"
    say "TSA104E: Makeacid routine aborting due to lack of user type"
    SAY "TSA104E:   acid = "name
    SAY "*********************************************************"
    RETURN
  END
  DIV = ""
  TYPE = ""
  DEPT = ""
  ZONE = ""
  CREATE_NUM = CREATE_NUM + 1
  CREATE.CREATE_NUM = "  "T2
  CREATE_NUM = CREATE_NUM + 1
  if makeacid.0custom = "YES" then do
    thecmd = makeacid.0custom.command
    parse var thecmd q1 '$$' q2
    aname = name
    if convert.0newid = "YES" then aname = convert.0name
    create.create_num = q1||aname||q2
    create_num = create_num + 1
  end
  CREATE.CREATE_NUM = "  "
  CREATE.0 = CREATE_NUM
end
/* say "leaving makeacid dept = " dept  */
if debug.makeacid = "YES" then
say "TSA101D: leaving makeacid # output = "create_num create.1 create.2
if screen = "YES" then do t1 = 1 to create_num
  say create.t1
end
return
/************/
convert: procedure expose cvtcmd. name bypass. hex00 uidcon defgroup,
  acidrul. cvtnum concat lcffac debug. convert. record_number allacid.
parse arg function segment inline
say "TSA101D: convert called with " function segment inline
name = getval(record_number,0acid)
oname = name
concat = getval(record_number,0concat)
if debug.newgdata = "YES" then concat = allacid.record_number.0concat
if oname = "*ALL*" then oname = "ALL"
if convert.0newid = "YES" then oname = convert.0name
if debug.flow = "YES" then
  say "TSA101D: output name for convert is " oname "concat is" concat
if debug.flow = "YES" then
  say "TSA101D: Converting for "name":"function segment ">"||inline||"<"
cmd_set = "ADD REM"
inword1 = word(inline,1)
if words(inline) = 1 then return
parse var inline gone fulline
if segment = "ADMINISTRATIONAUTHORITIES" THEN do
  cmd_set = "ADMIN DEADMIN"
  xa = "YES"
  concat = "YES"
  if index(inline,"*ALL*") <> 0 then do
    parse var inline hold0 '*ALL*' hold1
    inline = hold0||"ALL"||hold1
  end
end
cmd = word(cmd_set,1)
if function = "REVOKE" then cmd = word(cmd_set,2)
/*************************************************/
/** the reformatter area                        **/
/** for converting stuff that is unique and cant**/
/** be handled by the lower 'standard' area     **/
/** Word parsing has not occured yet so we can  **/
/** actually change the input line if we want   **/
/*************************************************/
if (inword1 = "BYPASSING") | (inword1 = "ATTRIBUTES"),
  then do
  hold = translate(substr(inline,11)," ",",")
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname")" hold
  if debug.convert = "YES" then
    say "  Reformatter area completed convert. returning."
  return /* we have converted the line so lets leave */
end
if (inword1 = "LCFFAC") then do
  lcffac = word(inline,2)
  if debug.convert = "YES" then
    say "  Reformatter area completed convert. returning."
  return  /* we have converted the line so lets leave */
end
if (inword1 = "XAVOLUME") then do
  /*********************************************************/
  /* a volume generic of (d,g) or (t,g) is invalid so we   */
  /* handle it here.                                       */
  /*********************************************************/
  where_gen = index(inline,",G)")
  if where_gen /= 0 then do
    if debug.convert = "YES" then
      say "TSA101D: Vol generic, Input dsn line "inline
     parse var inline hz1  ',' hz2
    inline = hz1||hz2
    if debug.convert = "YES" then
      say "TSA101D: Reformatted vol generic line "inline
  end
end
if (inword1 = "XADATASET") then do
  /*********************************************************/
  /* dataset is not a valid tss resource so we make it DSN */
  /* and let it fall through to the standard area, we do   */
  /* NOT return. We just make the resource valid and let   */
  /* the lower routine handle the rest.. DIR 14 april 2000 */
  /*********************************************************/
  if debug.convert = "YES" then
    say "TSA101D: Input dsn line "inline
  inline = "XADSN"||substr(inline,10)
  if debug.convert = "YES" then
    say "TSA101D: Reformatted dsn line "inline
end
if (substr(inword1,1,9) = "AUTHCMDS."),
   | (substr(inword1,1,9) = "EXMPCMDS.") then do
  /*********************************************************/
  /* This command syntax is so weird I am just going to    */
  /* the entire thing here.                                */
  /*                                                       */
  /*                                     DIR 14 april 2000 */
  /*********************************************************/
  lcmd = word(inline,2)
  lcffac = substr(inword1,10)
  hold = "("lcmd
  scmd = "XCMD"
  if (substr(inword1,1,9) = "AUTHCMDS.") then scmd = "CMD"
  Do wcnt = 3 to words(inline)
    lcmd = word(inline,wcnt)
    hold = hold","lcmd
  end
  hold = hold")"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") "SCMD"("lcffac","hold")"
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
if (inword1 = "INSTDATA") then do
  /*********************************************************/
  /* This command syntax is so weird I am just going to    */
  /* the entire thing here.                                */
  /*                                                       */
  /*                                     DIR 14 april 2000 */
  /*********************************************************/
  hold = translate(substr(inline,10)," ",",")
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") -"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " INSTDATA('"hold"')"
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
if (inword1 = "UID") then do
  /*********************************************************/
  /* Leading zeroes cause a syntax error so this routine   */
  /* is just to remove them.                               */
  /*                                                       */
  /*                                     DIR 14 april 2000 */
  /*********************************************************/
  theuid = word(inline,2)
  theuid = theuid + 0  /* strip the leading zeroes */
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = " TSS "cmd"("oname") UID("theuid")"
  if (uidcon = "NO") & (theuid / = 0 )  then
    cvtcmd.cvtnum = " %giveuid " oname defgroup
  if debug.convert = "YES" then
    say "TSA101D: Reformatter area completed convert. returning."
  return
end
/*************************************************/
/** end of the reformatter area                 **/
/*************************************************/
call vparse inline
/*************************************************/
/** the preprocessing area                      **/
/*************************************************/
IF (FUNCTION = "REVOKE") & (WORDPOS("UNTIL",INLINE) /= 0 ) THEN DO
  WTGT = WORDPOS("UNTIL",INLINE)
  do moveto = wtgt to words  /* shift everything left two words */
    movefrom = moveto + 2
    w.moveto = w.movefrom
  end
  words = words - 2
end
/*************************************************/
/** Below we change words to valid command      **/
/** parameters                                  **/
/*************************************************/
If w.1 = "VOLUMES" then w.1 = "VOLUME"
IF SEGMENT = "ADMINISTRATIONAUTHORITIES"  THEN do
  If w.1 = "FACILITIES" then w.1 = "FACILITY"
  If w.1 = "LISTDATA" then w.1 = "DATA"
  IF W.1 = "SCOPEACID" THEN W.1 = "SCOPE"
end
if w.1 = "MASTERFAC" then w.1 = "MAS"
IF W.1 = "PROFILE" THEN CONCAT = "YES"
IF W.1 = "FACILITY" THEN CONCAT = "YES"
  /*************************************************/
  /** above to support profile expiration        **/
  /*************************************************/
if w.1 = "LOCKTIME" then do
  words = 2                 /* drop the junk */
  if w.5 /= "*ALL*" then w.2 = (w.2","w.5)
  w.1 = "LTI"
end
holdz = w.1
if convert.0fulline.holdz = "YES"  then do
  /*************************************************/
  /** If we have a fulline resource text field   **/
  /** this is the place we handle it.            **/
  /*************************************************/
  reshold = convert.0resource.holdz
  cvtnum = cvtnum + 1
  aname = name
  if convert.0newid = "YES" then aname = convert.0name
  cvtcmd.cvtnum = " TSS "CMD"("aname")" reshold"('"fulline"')"
  return
end
if w.1 = "SITRAN" then do
  words = 2                 /* drop the junk */
  if w.4 /= "*ALL*" then w.2 = (w.2","w.4)
  w.1 = "SIT"
end
if name = "STC" then do
  if w.1 /= "STC" then return
  if w.2 = "*DEF*" then w.2 = "DEFAULT"
  HOLD  = " TSS "CMD"(STC) PROCNAME("W.2")                           "
  hold = substr(hold,1,35)
  HOLD  = hold "ACID("W.4")"
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum = hold
  return
end
/*************************************************/
/** end of the preprocessing area               **/
/*************************************************/
type = w.1
resource = w.2
tchk = w.2
if type = "XADSN" then tchk = "XADATASET"
/* the record number variable below is the record requested from */
/* the getdata routine or you can manually set it prior to a     */
/* convert call                                                  */
if getval(record_number,0concat) = "YES" then concat = "YES"
xa = "NO"
if substr(type,1,2) = "XA" then do
  xa = "YES"
  cmd_set = "PER REV"
  /* concat = "YES" */
  hold = getval(record_number,0concat)
  if hold = "YES" then concat = "YES"
  if debug.convert = "YES" then say "TSA101D: XA",
   "type ="type "res="resource "name="name,
   "concat = " concat
  type = substr(type,3)
  w.1 = type
end
if function = "REVOKE" then cmd = word(cmd_set,2)
if function = "PERMIT" then cmd = word(cmd_set,1)
if debug.convert = "YES" then
  say "TSA101D: Resource is "resource "concat is" concat
rulehold = 0
do q1 = 1 to bypass.function.0
  hold1 = word(bypass.function.q1,1)
  hold = word(bypass.function.q1,2)
  type_check = type
  if xa = "YES" then type_check = "XA"type
  if (hold1 = "*") | (hold1 = segment) then seg_match = "YES"
  if type_CHECK = hold then type_match = "YES"
  if (type_match = "YES") & (seg_match = "YES" ) then bypass = "YES"
  if (bypass = "YES") & (rulehold = 0 ) then rulehold = q1
  seg_match  = "NO"
  type_match = "NO"
end
/*                                                */
if bypass = "YES" then do
  if debug.convert = "YES" then do
    rule = bypass.function.rulehold
    say "TSA101D: bypass rule tripped, Rule is below:"
    say "     " Rule
  end
  return
end
/*******************************************************/
/* Now we create two command streams for the input the */
/* multi value (which is a command with multiple parms)*/
/* and the stack value( which is multiple commands     */
/* stacked together in one variable to be broken apart */
/* later). Most of the time all you should have to do  */
/* is select which of the command types is valid to    */
/* the input resource. If this is not the case you have*/
/* to put code in the pre or post formatting area.     */
/*                                                     */
/* If you suspect these areas are incorrect set the    */
/* debug.mutlcon variable to "YES" at the very         */
/* beginning of the exec and use the WRITEDEBUG        */
/* command to see the interim values.                  */
/*                                 DIR 14 April 2000   */
/*******************************************************/
output = " TSS "cmd"("oname")"
skeleton = " TSS "cmd"("oname")"
hold = ""
multi = output
/* the multi value is the tss command with multiple parms */
stack   = output
do c1 = 1 to words by 2
  next = c1 + 1
  multi = multi w.c1"("w.next")"
end
do c1 = 2 to words
  hold = hold"|"stack w.1"("w.c1")"
end
stack = hold
if debug.multcon = "YES" then do
  say "  Multi  rule  is =" multi
  say "  Stack  rule  is =" stack
  say "  Concat value is =" concat
end
/* say "Stack: =" stack  */
/* stack value is mutliple tss commands generated by one line */
/*                                                   */
/*if (function = "PERMIT") & ( xa /= "YES") then do  */
/*  do c1 = 2 to words                               */
/*    hold = hold w.c1                               */
/*  end                                              */
/*  output = output w.1"("hold")"                    */
/*end                                                */
output = multi
if (function = "REVOKE") & (cmd = "REM") then do
  if concat = "YES" then output = multi
  if concat /= "YES" then output = stack
end
if (function = "REVOKE") & (cmd = "REV") then do
  if concat = "YES" then output = multi
  if concat /= "YES" then output = stack
end
if (function = "PERMIT") | (function = "REBUILD") then do
  if concat = "YES" then output = multi
  if concat /= "YES" then output = stack
end
if debug.multcon = "YES" then do
  say "  Multi  rule  is =" multi
  say "  Stack  rule  is =" stack
  say "  Concat value is =" concat
end
parse var output tz1  '()' tz2
output = tz1 tz2
if debug.convert = "YES" then
  say "TSA101D:***** CONVERT OUTPUT IS NOW :" output
if index(output,"|") <> 0 then do
  parse var stack ot.1 '|' ot.2 '|' ot.3 '|' ot.4 '|' ot.5 '|' ot.6,
  ot.7 '|' ot.8 '|' ot.9 '|' ot.10 '|' ot.11 '|' ot.12 '|' ot.13,
  ot.14 '|' ot.15 '|' ot.16 '|' ot.17 '|' ot.18 '|' ot.19 '|' ot.20
  do w = 1 to 20
    if ot.w /= "" then do
      cvtnum = cvtnum + 1
      cvtcmd.cvtnum =  ot.w
    end
  end
end
if index(output,"|") = 0 then do
  if length(output) > 60 then do
    parse var output w1 w2 w3 w4
    cvtnum = cvtnum + 1
    cvtcmd.cvtnum = " "w1 w2 w3 "-"
    output = "    "w4
    if length(output) > 60 then do
      parse var output w1 w2 w3
      cvtnum = cvtnum + 1
      cvtcmd.cvtnum =  " "w1 w2 "-"
      output = "    "w3
    end
  end
  cvtnum = cvtnum + 1
  cvtcmd.cvtnum =  output
end
return
/*********************/
/*********************/
/*********************/
/*********************/
seeya: nop
if sysenv = "FORE" then do
  say  "T53ICOMP: error in line "sigl
  address ispexec "vput secrc profile"
  X = SOURCELINE(SIGL)
  say x
end
exit
/************/
vparse: procedure expose words w.
parse arg invar
w. = ""
words = words(invar)
do t = 1 to words
  w.t = word(invar,t)
end
return
/************************/
/************************/
/************************/
/************************/
badacid: nop
secrc = "TSA105E: TSS list command failed for ACID" acids.r
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR."
  say "passed acidlist was unlistable, check validity of acid" acids.r
  say "and your TOP SECRET authority."
  exit  8
end
say secrc
exit
/************************/
/************************/
/************************/
/************************/
baddsn: nop
secrc = "TSA106E: Unable to retrieve data to support bypass mode"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR. in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  exit  8
end
say secrc
exit
/************************/
badres: nop
secrc =,
 "TSA108E: TSS command failed, check resource type, name and authority"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  say "CMD issued: TSS whohas "w.1"("w.2")"
  say "TSS RESPONSE was:"
  say hold.1 hold.2
  exit  8
end
say secrc
exit
/************************/
badrdt: nop
secrc =,
 "TSA110E: RDT list failed, check resource type, name and authority"
if sysenv = "FORE" then do
  address ispexec "vput secrc profile"
  say "FATAL ERROR in line" sigl
  say "Passed DSN was invalid, check validity of DSN" ds1
  say "and environment variables."
  say "CMD issued: TSS list(rdt) resclass("w.1")"
  say "TSS RESPONSE was:"
  say hold.1 hold.2
  exit  8
end
say secrc
exit
/************************/
/************************/
/************************/
/************************/
fillscr: procedure expose thisrec outnum type. rsname. access. t,
 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 type1 type2 type3,
 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a. acids.,
 type4 type5 type6 type7 type8 type9 type10 type11 type12 type13,
 access1 access2 access3 access4 access5 access6 access7 access8,
 access9 access10 access11 access12 access13 access14 type14,
 rsname1 rsname2 rsname3 rsname4 rsname5 rsname6 rsname7 rsname8,
 rsname9 rsname10 rsname11 rsname12 rsname13 rsname14 acidrul.,
 f. allacid. name hex00 aciddup. debug. linenum function balout
OPT = " "
if debug.fillscr = "YES" then
  say "TSA101D: Fillscr invoked. Thisrec=" thisrec
if function = "BALANCE" then outnum = balout
IF THISREC < 1 THEN DO
   THISREC = 1
   MSG = "T53ICOMP: TOP OF DATA REACHED"
END
h1 = linenum - 13
tempz1 = linenum
/* save this value for the display below*/
if debug.fillscr = "YES" then
    say "TSA101D: h1=" h1 "acidrul."name".0="  tempz1
if h1 < 1 then h1 = 1
/*******************************************************/
/* Thisrec is the record at the top of the screen      */
/* H1 is the highest record number which should EVER   */
/* be at the top of the screen                         */
/*******************************************************/
IF (THISREC > h1) & (thisrec <> 1)  THEN DO
  THISREC = OUTNUM - 13
  MSG = "T53ICOMP: BOTTOM OF DATA REACHED"
  if debug.fillscr = "YES" then
    say "TSA101D: Bottom of data thisrec set to :"thisrec
END
IF THISREC < 1 THEN DO
   THISREC = 1
   MSG = "T53ICOMP: TOP OF DATA REACHED"
END
if debug.fillscr = "YES" then do
  say "FILLSCR: thisrec=" thisrec
  say "TSA101D: filling screen:",
    "outnum="outnum "thisrec="thisrec "h1="h1
end
do cnt = 1 to 14
  fill = thisrec + cnt - 1
  script = fill
  interpret "f."cnt "=  f"||cnt
  /* dont need segment here for doc                   */
  maxdata = acidrul.name.0
  if debug.fillscr = "YES" then do
    say "TSA101D: fillscr calling subfunctions with subscript:" script
    say "         maxdata is:" maxdata
  end
  segment       = segment(script)
  type          = type(script)
  type.fill     = type
  if substr(type.fill,1,2) = "XA" then type.fill = substr(type.fill,3)
  /*********************************************/
  /* remove the XA for filling the screen only */
  /*********************************************/
  resource.fill = resname(script)
  resource = resource.fill
  fchk = getflag(script)
  if debug.fillscr = "YES" then do
    say "TSA101D: fillscr segment="segment
    say "   type="type "resource="resource "fchk="fchk
  end
  if fchk /= hex00 then do
    type.fill = getflag(fill)
    if debug.fillscr = "YES" then do
      say "fillscr: type overlayed type, resource =" type resource
      say "fillscr: NEWTYPE  =" type.fill
    end
  end
  /* hold = segment type resource respass
  hold = restext(fill)
  if debug.fillscr = "YES" then
     say "FILLSCR restext:" hold
  parse var hold h1 'ACCESS ' access dropoff  */
  access.fill = access(fill)
  interpret "type"||cnt " =  type.fill"
  interpret "rsname"||cnt "= resource.fill"
  interpret "access"||cnt  "=  access.fill"
  l = type.fill resource.fill access.fill
  if debug.fillscr = "YES" then
     say "FILLSCR output:" l
  /* call convert function hold  */
end
RETURN
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
/************************/
Getopt: procedure expose f.,
 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OPT
OPT = " "
do t = 1 to 14
  interpret "f."t "=  f"||t
end
RETURN
/************************/
/************************/
/************************/
/************************/
secure: nop
return
/************************/
/************************/
/************************/
/************************/
snapshot: procedure expose name acidrul. aciddup. next
say "TSA101D: Dumping acidrul array for " name
do out = 1 to acidrul.name.0
  call getdata out
  say out "=" next
end
return
/************************/
/************************/
/************************/
/************************/
/************************/
snaplist: procedure expose  name acidrul. aciddup. next acidlst.
say "TSA101D: Dumping acidrul array for " name
do out = 1 to acidlst.name.0
  t = acidlst.name.out
  say t
end
return
/************************/
/************************/
/************************/
/************************/
delrule: nop
return
/************************/
/************************/
/************************/
/************************/
getdata: procedure expose acidrul. aciddup. next name,
  getdata. debug. record_number
/****************************************************************/
/* this routine passes the next translated data line for an acid*/
/****************************************************************/
arg record_number
if debug.getdata = "YES" then
  say "TSA101D: Getdata invoked with:" name record_number
t = record_number
segment  = strip(acidrul.name.t.0segment)
type     = strip(acidrul.name.t.0type)
resource = strip(acidrul.name.t.0resname)
theres   = strip(acidrul.name.t.0restext)
dupchk   = ""
dupnum   = ""
if debug.getdata = "YES" then do
  say "TSA101D: Getdata base resource:" acidrul.name.t.0resname
  say "TSA101D: Getdata resource data:" theres
end
if dupchk = "DUPLICATE" then do
  theres = aciddup.name.type.resource.dupnum
  if debug.getdata = "YES" then
    say "Getdata:Record # " t "Duplicate processing:" dupnum theres
end
next = segment type resource theres
if debug.getdata = "YES" then
  say "TSA101D: Getdata returning:" next
getdata.0segment  = segment
getdata.0type     = type
getdata.0resource = resource
return
/****************************************************************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
/****************************************************************/
getadata: procedure expose allacid. name next,
  getdata. debug.
/****************************************************************/
/* this routine passes the next translated data line for an acid*/
/****************************************************************/
arg record_number
if debug.getdata = "YES" then do
  say "TSA101D: Getadata invoked with:" record_number
  say "New Getadata results:"
  say allacid.t
  say allacid.t.0segment
  say allacid.t.0type
  say allacid.t.0resname
  say allacid.t.0restext
  say "*******"
end
t = record_number
debug.newgdata = "YES"
segment  = strip(allacid.t.0segment)
type     = strip(allacid.t.0type)
resource = strip(allacid.t.0resname)
theres   = strip(allacid.t.0restext)
if debug.Getdata = "YES" then do
  say "TSA101D: Getadata base resource:" allacid.t
  say "TSA101D: Getadata resource data:" theres
end
next = segment type resource theres
if debug.getdata = "YES" then
  say "TSA101D: Getdata returning:" next
getdata.0segment  = segment
getdata.0type     = type
getdata.0resource = resource
return
/************************/
/************************/
/************************/
/************************/
deblank: NOP
arg in
deblnk.0out = ""
do deblnk = 1 to words(in)
  deblnk.0out = deblnk.0out word(in,deblnk)
end
result = deblnk.0out
return result
/************************/
/************************/
/************************/
/************************/
segment: NOP
arg tempin
result = getval(tempin,0segment)
say "Segment returning" result
return result
/************************/
/************************/
/************************/
/************************/
/*******************************************************/
/*******************************************************/
/**Gets the access from a string parens must be gone  **/
/**prior to invocation.                               **/
/*******************************************************/
/*******************************************************/
ACCESS: NOP
arg tempin
tempt   = restext(tempin)
parse var tempt h1 'ACCESS ' access dropoff
result = access
return result
/************************/
/************************/
/************************/
/************************/
type: NOP
arg tempin
result = getval(tempin,0type)
return result
/************************/
/************************/
/************************/
/************************/
resname: NOP
arg tempin
result = getval(tempin,0resname)
return result
/************************/
/************************/
/************************/
/************************/
restext: NOP
arg tempin
result = getval(tempin,0restext)
return result
/************************/
/************************/
/************************/
/************************/
setflag: NOP
tempin  = arg(1)
theflag = arg(2)
say "SETFLAG: setting record number " tempin " flag to " theflag
acidrul.name.tempin.0flag = theflag
setv = setval(tempin,0flag,theflag)
return 0
/************************/
/************************/
getval: NOP
/*******************************************************/
/*******************************************************/
/**Gets the allacid array variable specified.         **/
/*******************************************************/
/*******************************************************/
record  = arg(1)
varname = arg(2)
result = allacid.record.varname
return result
/************************/
/************************/
setval: NOP
/*******************************************************/
/*******************************************************/
/**sets the allacid array variable to specified value **/
/*******************************************************/
/*******************************************************/
record  = arg(1)
varname = arg(2)
newvalue= arg(3)
/*
say "SETVAL: SIGL" sigl" rec #" record " val:" varname "to" newvalue
  */
allacid.record.varname = newvalue
if varname = "RESET" then
allacid.record  = newvalue
return 0
/************************/
/************************/
/************************/
/************************/
getflag: NOP
tempin  = arg(1)
res    = getval(tempin,0flag)
/* say "getflag: " res */
return res
/************************/
/************************/
/************************/
/************************/
resname: NOP
arg tempin
result = getval(tempin,0resname)
return result
/************************/
/************************/
/************************/
/************************/
modrule: procedure expose thisrec outnum type. rsname. access. t,
 rsname  library type access facility action until privpgm other,
 f. name acidrul. conlist modrule. rstype debug.,
 fill_override allacid.
 /*************************************************************/
 /*************************************************************/
 /** This routine displays a screen and returns the variable **/
 /** conlist which is preformatted for a call to the convert **/
 /** routine.                                                **/
 /*************************************************************/
 /** output                                                  **/
 /** modrule.newrs        the new resource value             **/
 /**        rsname        the new resource name              **/
 /**        conlist       preformatted convert input         **/
 /*************************************************************/
OPT = " "
if debug.modrule = "YES" then
  say "MODRULE: Initial: t="t "thisrec="thisrec "Fill="fill
/*
if thisrec < 1 then do
   thisrec = 1
   msg = "T53ICOMP: top of data reached"
end
h1 = acidrul.name.0 - 14
if h1 < 1 then h1 = 1
if (thisrec > h1 )  then do
  thisrec = h1
  msg = "T53ICOMP: bottom of data reached"
end
*/
fill = thisrec + t - 1
if debug.modrule = "YES" then
  say "MODRULE: Resolved: t="t "thisrec="thisrec "Fill="fill
if fill_override /= 0 then do
  fill = fill_override
  fill_override = 0
  if debug.modrule = "YES" then
  say "MODRULE: fill_overide found is :" fill_override "ACID=" name
  /*******************************************************************/
  /* this fill_override variable allows the balance routine to       */
  /* bypass normal processing and pass me the subscript.             */
  /*******************************************************************/
end
interpret "f."t "=  f"||t
/* dont need segment here for doc                   */
segment = segment(fill)
type    = type(fill)
resource= resname(fill)
rsname  = resname(fill)
modrule.newrs = ""
hold = restext(fill)
do modcnt = 1 to modrule.0parse.0
  target = modrule.0parse.modcnt
  interpret target " =  ''"
  if index(hold,target) <> 0 then do
    parse var hold h1 (target) gotit dropoff
    hold = h1 dropoff
    say "modrule:parse hit #"modcnt" setting " target "to" gotit
    say "modrule:remaining line" hold
    interpret   target " =  gotit"
    /* modrule.newrs = modrule.newrs target gotit    */
    /* say "modrule: new resource is " modrule.newrs   */
  end
end
other = hold
other = Deblank(other)
l = rsname library type access facility action until privpgm other
if debug.modrule = "YES" then
  say "MODRULE:prepanel" l
address ispexec "vput (action access library until type rsname) profile"
address ispexec "vput (facility privpgm ) profile"
address ispexec "addpop poploc(data2)"
/* address ispexec "setmsg msg(tssm000) msgloc(popmsg)" */
address ispexec "display panel("modrule.0panel")"
address ispexec "rempop"
conlist = segment type rsname
if access   /= " " then conlist = conlist "ACCESS " access
if facility /= " " then conlist = conlist "FAC " facility
if action   /= " " then conlist = conlist "ACTION "action
if until    /= " " then conlist = conlist "UNTIL "until
if privpgm  /= " " then conlist = conlist "PRIVPGM "privpgm
if other    /= " " then conlist = conlist other
if debug.modrule = "YES" then
  say "MODRULE:postpanel" conlist
do p = 4 to words(conlist)
  modrule.newrs = modrule.newrs word(conlist,p)
end
if debug.modrule = "YES" then
  say "Modrule: final conlist" conlist
/* call convert function hold  */
RETURN
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
/******************************************************************/
